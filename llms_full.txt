GROUNDSWELL - LLM DOCUMENTATION
Generated: 2025-12-08T19:45:49.651Z
================================================================================

This file contains the complete documentation and examples for the Groundswell project.
It is auto-generated by scripts/generate-llms-full.ts

Contents:
  1. PROJECT README
  2. DOCUMENTATION: WORKFLOW
  3. DOCUMENTATION: AGENT
  4. DOCUMENTATION: PROMPT
  5. EXAMPLES OVERVIEW
  6. EXAMPLE: EXAMPLE 1: BASIC WORKFLOW
  7. EXAMPLE: EXAMPLE 2: DECORATOR OPTIONS
  8. EXAMPLE: EXAMPLE 3: PARENT CHILD
  9. EXAMPLE: EXAMPLE 4: OBSERVERS DEBUGGER
  10. EXAMPLE: EXAMPLE 5: ERROR HANDLING
  11. EXAMPLE: EXAMPLE 6: CONCURRENT TASKS
  12. EXAMPLE: EXAMPLE 7: AGENT LOOPS
  13. EXAMPLE: EXAMPLE 8: SDK FEATURES
  14. EXAMPLE: EXAMPLE 9: REFLECTION
  15. EXAMPLE: EXAMPLE 10: INTROSPECTION

================================================================================
PROJECT README
File: README.md
================================================================================

# Groundswell

Hierarchical workflow orchestration engine with full observability.

## Installation

```bash
npm install groundswell
```

**Requirements:** Node.js 18+, TypeScript 5.2+

## Quick Start

### Class-Based Workflow

```typescript
import { Workflow, Step, ObservedState, WorkflowTreeDebugger } from 'groundswell';

class DataProcessor extends Workflow {
  @ObservedState()
  progress = 0;

  @Step({ trackTiming: true, snapshotState: true })
  async process(): Promise<string[]> {
    this.progress = 100;
    return ['item1', 'item2', 'item3'];
  }

  async run(): Promise<string[]> {
    this.setStatus('running');
    const result = await this.process();
    this.setStatus('completed');
    return result;
  }
}

const workflow = new DataProcessor('DataProcessor');
const debugger_ = new WorkflowTreeDebugger(workflow);

const result = await workflow.run();
console.log(debugger_.toTreeString());
```

### Functional Workflow

```typescript
import { createWorkflow } from 'groundswell';

const workflow = createWorkflow(
  { name: 'DataPipeline' },
  async (ctx) => {
    const loaded = await ctx.step('load', async () => fetchData());
    const processed = await ctx.step('process', async () => transform(loaded));
    return processed;
  }
);

const result = await workflow.run();
```

### Agent with Prompt

```typescript
import { createAgent, createPrompt } from 'groundswell';
import { z } from 'zod';

const agent = createAgent({
  name: 'AnalysisAgent',
  enableCache: true,
});

const prompt = createPrompt({
  user: 'Analyze this code for bugs',
  data: { code: 'function foo() { return 42; }' },
  responseFormat: z.object({
    bugs: z.array(z.string()),
    severity: z.enum(['low', 'medium', 'high']),
  }),
});

const result = await agent.prompt(prompt);
// result is typed as { bugs: string[], severity: 'low' | 'medium' | 'high' }
```

## Documentation

- [Workflows](docs/workflow.md) - Hierarchical task orchestration
- [Agents](docs/agent.md) - LLM execution with caching and reflection
- [Prompts](docs/prompt.md) - Type-safe prompt definitions with Zod

### For AI Agents

Full documentation in a single file: [`llms_full.txt`](llms_full.txt)

Generate with `npm run generate:llms`

## Core Concepts

### Workflows

The primary orchestration unit. Manage execution status, emit events, and support hierarchical parent-child relationships. Two patterns are supported:
- **Class-based**: Extend `Workflow` and override `run()`
- **Functional**: Use `createWorkflow()` with an executor function

### Agents

Lightweight wrappers around the Anthropic SDK. Execute prompts, manage tool invocation cycles, and integrate with caching and reflection systems.

### Prompts

Immutable value objects defining what to send to an agent and how to validate the response using Zod schemas.

## Decorators

```typescript
// Emit lifecycle events and track timing
@Step({ trackTiming: true, snapshotState: true })
async processData(): Promise<void> { }

// Spawn and manage child workflows
@Task({ concurrent: true })
async createWorkers(): Promise<WorkerWorkflow[]> { }

// Mark fields for state snapshots
@ObservedState()
progress: number = 0;

@ObservedState({ redact: true })  // Shown as '***'
apiKey: string = 'secret';
```

## Caching

LLM responses are cached using deterministic SHA-256 keys:

```typescript
import { createAgent, defaultCache } from 'groundswell';

const agent = createAgent({ enableCache: true });

const result1 = await agent.prompt(prompt);  // API call
const result2 = await agent.prompt(prompt);  // Cached

console.log(defaultCache.metrics());  // { hits: 1, misses: 1, hitRate: 50 }
```

## Reflection

Multi-level error recovery with automatic retry:

```typescript
const workflow = createWorkflow(
  { name: 'MyWorkflow', enableReflection: true },
  async (ctx) => {
    await ctx.step('unreliable-operation', async () => {
      // If this fails, reflection will analyze and retry
    });
  }
);
```

## Introspection Tools

Agents can inspect their position in the workflow hierarchy:

```typescript
import { INTROSPECTION_TOOLS, createAgent } from 'groundswell';

const agent = createAgent({
  name: 'IntrospectionAgent',
  tools: INTROSPECTION_TOOLS,  // 6 tools for hierarchy navigation
});
```

## Examples

```bash
npm run start:all              # Interactive runner
npm run start:basic            # Basic workflow
npm run start:decorators       # Decorator options
npm run start:parent-child     # Hierarchical workflows
npm run start:observers        # Observers and debugger
npm run start:errors           # Error handling
npm run start:concurrent       # Concurrent tasks
npm run start:agent-loops      # Agent loops
npm run start:sdk-features     # Tools, MCPs, hooks
npm run start:reflection       # Multi-level reflection
npm run start:introspection    # Introspection tools
```

See [examples/](examples/) for source code.

## API Reference

| Category | Exports |
|----------|---------|
| **Core** | `Workflow`, `Agent`, `Prompt`, `MCPHandler` |
| **Factories** | `createWorkflow`, `createAgent`, `createPrompt` |
| **Decorators** | `@Step`, `@Task`, `@ObservedState` |
| **Caching** | `LLMCache`, `defaultCache`, `generateCacheKey` |
| **Reflection** | `ReflectionManager`, `executeWithReflection` |
| **Introspection** | `INTROSPECTION_TOOLS`, `handleInspectCurrentNode`, ... |
| **Debugging** | `WorkflowTreeDebugger`, `Observable` |

## Contributing

Contributions and issues are welcome.

## Support

If Groundswell helps you build something great, consider fueling future development:

<a href="https://buymeacoffee.com/dustindsch2" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" height="50"></a>

## License

MIT


================================================================================
DOCUMENTATION: WORKFLOW
File: docs/workflow.md
================================================================================

# Workflows

Workflows are hierarchical task containers with built-in logging, state observation, and event emission.

## Table of Contents

- [Basic Usage](#basic-usage)
- [Functional Pattern](#functional-pattern)
- [Decorators](#decorators)
- [Parent-Child Workflows](#parent-child-workflows)
- [Observers](#observers)
- [Tree Debugger](#tree-debugger)
- [Error Handling](#error-handling)
- [Concurrent Execution](#concurrent-execution)
- [API Reference](#api-reference)

## Basic Usage

Extend `Workflow` and implement `run()`:

```typescript
import { Workflow } from 'groundswell';

class DataProcessor extends Workflow {
  async run(): Promise<string[]> {
    this.setStatus('running');
    this.logger.info('Processing started');

    const result = await this.processData();

    this.setStatus('completed');
    return result;
  }

  private async processData(): Promise<string[]> {
    return ['item1', 'item2'];
  }
}

const workflow = new DataProcessor('MyProcessor');
const result = await workflow.run();
```

### Workflow Status

```
idle -> running -> completed
                -> failed
                -> cancelled
```

| Status | Description |
|--------|-------------|
| `idle` | Created but not started |
| `running` | Currently executing |
| `completed` | Finished successfully |
| `failed` | Terminated with error |
| `cancelled` | Manually cancelled |

### Logger

Every workflow has a built-in logger:

```typescript
this.logger.debug('Debug message', { data });
this.logger.info('Info message');
this.logger.warn('Warning message');
this.logger.error('Error message', { error });
```

## Functional Pattern

Create workflows without subclassing:

```typescript
import { createWorkflow } from 'groundswell';

const workflow = createWorkflow(
  { name: 'DataPipeline', enableReflection: true },
  async (ctx) => {
    const loaded = await ctx.step('load', async () => {
      return fetchData();
    });

    const processed = await ctx.step('process', async () => {
      return transform(loaded);
    });

    await ctx.step('save', async () => {
      return persist(processed);
    });

    return processed;
  }
);

const result = await workflow.run();
console.log(result.data);      // The actual result
console.log(result.duration);  // Execution time in ms
```

### WorkflowContext

The context provides methods for composing workflows:

| Method | Description |
|--------|-------------|
| `step(name, fn)` | Execute a named step with event tracking |
| `spawnWorkflow(workflow)` | Spawn and attach a child workflow |
| `replaceLastPromptResult(prompt, agent)` | Replace last prompt result without tree branching |

## Decorators

### @Step

Wraps methods with event emission and error handling.

```typescript
import { Step } from 'groundswell';

class MyWorkflow extends Workflow {
  // Default - emits stepStart/stepEnd events
  @Step()
  async basicStep(): Promise<void> {}

  // Custom name
  @Step({ name: 'CustomStepName' })
  async namedStep(): Promise<void> {}

  // Capture state after completion
  @Step({ snapshotState: true })
  async snapshotStep(): Promise<void> {}

  // Track execution duration
  @Step({ trackTiming: true })
  async timedStep(): Promise<void> {}

  // Log start/end messages
  @Step({ logStart: true, logFinish: true })
  async loggedStep(): Promise<void> {}

  // All options
  @Step({
    name: 'FullStep',
    snapshotState: true,
    trackTiming: true,
    logStart: true,
    logFinish: true,
  })
  async fullStep(): Promise<void> {}
}
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `name` | `string` | Custom step name (defaults to method name) |
| `snapshotState` | `boolean` | Capture state snapshot after step completion |
| `trackTiming` | `boolean` | Track and emit step duration |
| `logStart` | `boolean` | Log message when step starts |
| `logFinish` | `boolean` | Log message when step completes |

### @Task

Wraps methods that return child workflows.

```typescript
import { Task } from 'groundswell';

class ParentWorkflow extends Workflow {
  // Basic - attaches returned workflow as child
  @Task()
  async createChild(): Promise<ChildWorkflow> {
    return new ChildWorkflow('Child', this);
  }

  // Custom name
  @Task({ name: 'SpawnWorker' })
  async spawnWorker(): Promise<WorkerWorkflow> {
    return new WorkerWorkflow('Worker', this);
  }

  // Concurrent - runs all returned workflows in parallel
  @Task({ concurrent: true })
  async createWorkers(): Promise<WorkerWorkflow[]> {
    return [
      new WorkerWorkflow('W1', this),
      new WorkerWorkflow('W2', this),
      new WorkerWorkflow('W3', this),
    ];
  }

  async run(): Promise<void> {
    const child = await this.createChild();
    await child.run();
  }
}
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `name` | `string` | Custom task name |
| `concurrent` | `boolean` | Run returned workflows in parallel |

### @ObservedState

Marks fields for inclusion in state snapshots.

```typescript
import { ObservedState, getObservedState } from 'groundswell';

class MyWorkflow extends Workflow {
  // Included in snapshots
  @ObservedState()
  progress = 0;

  // Shown as '***' in snapshots
  @ObservedState({ redact: true })
  apiKey = 'secret';

  // Excluded from snapshots
  @ObservedState({ hidden: true })
  internalState = {};

  async run(): Promise<void> {
    this.progress = 50;

    // Get current state snapshot
    const state = getObservedState(this);
    // { progress: 50, apiKey: '***' }
  }
}
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `hidden` | `boolean` | Exclude field from snapshots entirely |
| `redact` | `boolean` | Show value as `'***'` in snapshots |

## Parent-Child Workflows

Workflows form a hierarchy. Pass the parent to the constructor:

```typescript
class ChildWorkflow extends Workflow {
  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Child executing');
    this.setStatus('completed');
  }
}

class ParentWorkflow extends Workflow {
  @Task()
  async spawnChild(): Promise<ChildWorkflow> {
    return new ChildWorkflow('Child', this); // 'this' is parent
  }

  async run(): Promise<void> {
    this.setStatus('running');

    const child = await this.spawnChild();
    await child.run();

    // Access children
    console.log(this.children.length); // 1

    this.setStatus('completed');
  }
}
```

Events from children propagate to observers on the root workflow.

## Observers

Attach observers to the root workflow to receive all events:

```typescript
import { WorkflowObserver, LogEntry, WorkflowEvent, WorkflowNode } from 'groundswell';

const observer: WorkflowObserver = {
  onLog(entry: LogEntry): void {
    console.log(`[${entry.level}] ${entry.message}`);
  },

  onEvent(event: WorkflowEvent): void {
    console.log(`Event: ${event.type}`);
  },

  onStateUpdated(node: WorkflowNode): void {
    console.log(`State updated: ${node.name}`);
  },

  onTreeChanged(root: WorkflowNode): void {
    console.log('Tree structure changed');
  },
};

const workflow = new MyWorkflow('Root');
workflow.addObserver(observer);
await workflow.run();
```

### Event Types

| Type | Description |
|------|-------------|
| `stepStart` | Step execution started |
| `stepEnd` | Step completed, includes `duration` |
| `taskStart` | Task execution started |
| `taskEnd` | Task completed |
| `childAttached` | Child workflow attached |
| `stateSnapshot` | State snapshot captured |
| `error` | Error occurred |
| `treeUpdated` | Tree structure changed |

## Tree Debugger

Visualize workflow execution:

```typescript
import { WorkflowTreeDebugger } from 'groundswell';

const workflow = new ParentWorkflow('Root');
const debugger_ = new WorkflowTreeDebugger(workflow);

await workflow.run();

// ASCII tree
console.log(debugger_.toTreeString());
// Root [completed]
//   Child-1 [completed]
//   Child-2 [completed]

// Formatted logs
console.log(debugger_.toLogString());

// Statistics
console.log(debugger_.getStats());
// { totalNodes: 3, byStatus: { completed: 3 }, totalLogs: 10, totalEvents: 15 }

// Find node by ID
const node = debugger_.getNode(workflow.id);

// Subscribe to events
debugger_.events.subscribe({
  next: (event) => console.log(event.type),
});
```

### Status Symbols

| Symbol | Status |
|--------|--------|
| o | idle |
| - | running |
| + | completed |
| x | failed |
| / | cancelled |

## Error Handling

Errors in `@Step` methods are wrapped in `WorkflowError` with full context:

```typescript
import { WorkflowError } from 'groundswell';

class MyWorkflow extends Workflow {
  @ObservedState()
  currentItem = '';

  @Step({ snapshotState: true })
  async process(): Promise<void> {
    this.currentItem = 'item-1';
    throw new Error('Processing failed');
  }

  async run(): Promise<void> {
    try {
      await this.process();
    } catch (error) {
      const wfError = error as WorkflowError;

      console.log(wfError.message);     // 'Processing failed'
      console.log(wfError.workflowId);  // workflow ID
      console.log(wfError.state);       // { currentItem: 'item-1' }
      console.log(wfError.logs);        // logs up to error
      console.log(wfError.stack);       // stack trace
    }
  }
}
```

### Retry Pattern

```typescript
class RetryWorkflow extends Workflow {
  @ObservedState()
  attempt = 0;

  @Step()
  async unreliableOperation(): Promise<void> {
    this.attempt++;
    if (this.attempt < 3) {
      throw new Error('Temporary failure');
    }
  }

  async run(): Promise<void> {
    const maxAttempts = 3;

    while (this.attempt < maxAttempts) {
      try {
        await this.unreliableOperation();
        break;
      } catch (error) {
        if (this.attempt >= maxAttempts) throw error;
        await this.delay(1000 * this.attempt); // backoff
      }
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(r => setTimeout(r, ms));
  }
}
```

### Error Isolation

Parent workflows can catch and handle child errors:

```typescript
class ResilientParent extends Workflow {
  async run(): Promise<void> {
    for (const config of this.childConfigs) {
      const child = new ChildWorkflow(config, this);

      try {
        await child.run();
      } catch (error) {
        this.logger.warn(`Child failed: ${error.message}`);
        // Continue with other children
      }
    }
  }
}
```

## Concurrent Execution

### Sequential (default)

```typescript
for (const item of items) {
  const worker = await this.createWorker(item);
  await worker.run(); // waits for each
}
```

### Parallel with @Task

```typescript
@Task({ concurrent: true })
async createWorkers(): Promise<Worker[]> {
  return items.map(item => new Worker(item, this));
}

// All workers run in parallel when method completes
```

### Manual Parallel

```typescript
const workers = await Promise.all(
  items.map(item => this.createWorker(item))
);

const results = await Promise.all(
  workers.map(w => w.run())
);
```

### Fan-Out / Fan-In

```typescript
class Pipeline extends Workflow {
  @Step()
  async fanOut(): Promise<string[]> {
    const workers = this.items.map(
      item => new Worker(item, this)
    );

    // Run all in parallel
    return Promise.all(workers.map(w => w.run()));
  }

  @Step()
  async fanIn(results: string[]): Promise<void> {
    this.aggregatedResult = results.join(',');
  }

  async run(): Promise<void> {
    const results = await this.fanOut();
    await this.fanIn(results);
  }
}
```

## API Reference

### Workflow Class

```typescript
class Workflow<T = unknown> {
  readonly id: string;
  parent: Workflow | null;
  children: Workflow[];
  status: WorkflowStatus;

  constructor(name?: string, parent?: Workflow);
  constructor(config: WorkflowConfig, executor: WorkflowExecutor<T>);

  run(...args: unknown[]): Promise<T | WorkflowResult<T>>;

  protected setStatus(status: WorkflowStatus): void;
  protected readonly logger: WorkflowLogger;

  addObserver(observer: WorkflowObserver): void;
  removeObserver(observer: WorkflowObserver): void;
  attachChild(child: Workflow): void;
  snapshotState(): void;
  getNode(): WorkflowNode;
  emitEvent(event: WorkflowEvent): void;
}
```

### Types

```typescript
type WorkflowStatus = 'idle' | 'running' | 'completed' | 'failed' | 'cancelled';

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

interface WorkflowConfig {
  name?: string;
  enableReflection?: boolean;
}

interface WorkflowResult<T> {
  data: T;
  node: WorkflowNode;
  duration: number;
}

interface LogEntry {
  id: string;
  workflowId: string;
  timestamp: number;
  level: LogLevel;
  message: string;
  data?: unknown;
  parentLogId?: string;
}

interface WorkflowError {
  message: string;
  original: unknown;
  workflowId: string;
  stack?: string;
  state: Record<string, unknown>;
  logs: LogEntry[];
}

interface WorkflowNode {
  id: string;
  name: string;
  parent: WorkflowNode | null;
  children: WorkflowNode[];
  status: WorkflowStatus;
  logs: LogEntry[];
  events: WorkflowEvent[];
  stateSnapshot: Record<string, unknown> | null;
}

interface WorkflowObserver {
  onLog(entry: LogEntry): void;
  onEvent(event: WorkflowEvent): void;
  onStateUpdated(node: WorkflowNode): void;
  onTreeChanged(root: WorkflowNode): void;
}
```

See [examples/07-agent-loops.ts](../examples/examples/07-agent-loops.ts) for workflow usage with agents.


================================================================================
DOCUMENTATION: AGENT
File: docs/agent.md
================================================================================

# Agents

Agents are lightweight wrappers around the Anthropic SDK that execute prompts, manage tool invocation cycles, and integrate with caching and reflection systems.

## Table of Contents

- [Basic Usage](#basic-usage)
- [Configuration](#configuration)
- [Executing Prompts](#executing-prompts)
- [Reflection](#reflection)
- [Tools and MCP](#tools-and-mcp)
- [Hooks](#hooks)
- [Caching](#caching)
- [API Reference](#api-reference)

## Basic Usage

```typescript
import { createAgent, createPrompt } from 'groundswell';
import { z } from 'zod';

const agent = createAgent({
  name: 'AnalysisAgent',
  model: 'claude-sonnet-4-20250514',
  enableCache: true,
});

const prompt = createPrompt({
  user: 'Analyze this code for bugs',
  data: { code: 'function foo() { return 42; }' },
  responseFormat: z.object({
    bugs: z.array(z.string()),
    severity: z.enum(['low', 'medium', 'high']),
  }),
});

const result = await agent.prompt(prompt);
// result is typed: { bugs: string[], severity: 'low' | 'medium' | 'high' }
```

## Configuration

### AgentConfig

```typescript
interface AgentConfig {
  name?: string;                    // Human-readable name
  system?: string;                  // System prompt
  tools?: Tool[];                   // Available tools
  mcps?: MCPServer[];               // MCP servers to connect
  skills?: Skill[];                 // Skills to load
  hooks?: AgentHooks;               // Lifecycle hooks
  env?: Record<string, string>;     // Environment variables
  enableReflection?: boolean;       // Enable reflection capability
  enableCache?: boolean;            // Enable response caching
  model?: string;                   // Model to use
  maxTokens?: number;               // Max tokens for responses
  temperature?: number;             // Response temperature
}
```

### Configuration Priority

Configuration follows a three-level override hierarchy:

1. **Prompt-level** (highest priority)
2. **Execution-level** (via `PromptOverrides`)
3. **Agent-level** (lowest priority)

```typescript
const agent = createAgent({
  system: 'Default system prompt',  // Agent-level
  model: 'claude-sonnet-4-20250514',
});

const prompt = createPrompt({
  user: 'Hello',
  system: 'Override system prompt',  // Prompt-level (wins)
  responseFormat: z.object({ response: z.string() }),
});

// Or override at execution time
const result = await agent.prompt(prompt, {
  model: 'claude-opus-4-5-20251101',  // Execution-level override
});
```

## Executing Prompts

### prompt()

Returns validated response data:

```typescript
const result = await agent.prompt(prompt);
// result is T (the response type)
```

### promptWithMetadata()

Returns full execution metadata:

```typescript
const result = await agent.promptWithMetadata(prompt);

console.log(result.data);       // Validated response
console.log(result.usage);      // { input_tokens, output_tokens }
console.log(result.duration);   // Total time in ms
console.log(result.toolCalls);  // Number of tool invocations
```

### PromptResult

```typescript
interface PromptResult<T> {
  data: T;                  // Validated response
  usage: TokenUsage;        // Token usage stats
  duration: number;         // Duration in milliseconds
  toolCalls: number;        // Number of tool calls
}

interface TokenUsage {
  input_tokens: number;
  output_tokens: number;
}
```

## Reflection

Enable self-correction with the `reflect()` method:

```typescript
const agent = createAgent({
  name: 'ReflectiveAgent',
  enableReflection: true,
});

const result = await agent.reflect(prompt);
```

The reflection system prepends a reflection prefix to the system prompt:

```
Before answering, reflect on your reasoning step by step.
Consider alternative approaches and potential errors.
Then provide your final answer.
```

### Reflection Configuration

```typescript
// Agent-level
const agent = createAgent({
  enableReflection: true,
});

// Prompt-level
const prompt = createPrompt({
  user: 'Complex question',
  enableReflection: true,
  responseFormat: schema,
});

// Execution-level
const result = await agent.prompt(prompt, {
  enableReflection: true,
});
```

## Tools and MCP

### Tool Definition

```typescript
import type { Tool } from 'groundswell';

const calculatorTool: Tool = {
  name: 'calculate',
  description: 'Performs arithmetic operations',
  input_schema: {
    type: 'object',
    properties: {
      operation: { type: 'string', enum: ['add', 'subtract', 'multiply', 'divide'] },
      a: { type: 'number' },
      b: { type: 'number' },
    },
    required: ['operation', 'a', 'b'],
  },
};
```

### MCP Handler

Register tools with an MCP handler:

```typescript
import { MCPHandler } from 'groundswell';

const mcpHandler = new MCPHandler();

mcpHandler.registerServer({
  name: 'demo',
  transport: 'inprocess',
  tools: [calculatorTool],
});

mcpHandler.registerToolExecutor('demo', 'calculate', async (input) => {
  const { operation, a, b } = input;
  switch (operation) {
    case 'add': return { result: a + b };
    case 'subtract': return { result: a - b };
    case 'multiply': return { result: a * b };
    case 'divide': return { result: a / b };
  }
});

const agent = createAgent({
  tools: mcpHandler.getTools(),
});
```

### Tool Execution Flow

1. Agent sends prompt to API
2. API requests tool use
3. Agent executes tool via MCP handler
4. Result sent back to API
5. Loop continues until no more tool calls
6. Final response validated and returned

## Hooks

Lifecycle hooks enable logging, monitoring, and custom processing:

```typescript
import type { AgentHooks, PreToolUseContext, PostToolUseContext } from 'groundswell';

const hooks: AgentHooks = {
  preToolUse: [
    async (ctx: PreToolUseContext) => {
      console.log(`[PRE] Tool: ${ctx.toolName}`);
      console.log(`Input:`, ctx.input);
    }
  ],
  postToolUse: [
    async (ctx: PostToolUseContext) => {
      console.log(`[POST] Tool: ${ctx.toolName}`);
      console.log(`Output:`, ctx.output);
      console.log(`Duration: ${ctx.duration}ms`);
    }
  ],
  sessionStart: [
    async (ctx) => {
      console.log(`Session started: ${ctx.agentName}`);
    }
  ],
  sessionEnd: [
    async (ctx) => {
      console.log(`Session ended: ${ctx.totalDuration}ms`);
    }
  ],
};

const agent = createAgent({
  hooks,
});
```

### Hook Types

| Hook | Trigger | Context |
|------|---------|---------|
| `preToolUse` | Before tool execution | `toolName`, `input` |
| `postToolUse` | After tool execution | `toolName`, `input`, `output`, `duration` |
| `sessionStart` | Before prompt execution | `agentName`, `promptId` |
| `sessionEnd` | After prompt execution | `agentName`, `totalDuration` |

## Caching

### Enable Caching

```typescript
const agent = createAgent({
  enableCache: true,
});

// First call: API request made, result cached
const result1 = await agent.prompt(prompt);

// Second call: cached result returned
const result2 = await agent.prompt(prompt);
```

### Cache Metrics

```typescript
import { defaultCache } from 'groundswell';

const metrics = defaultCache.metrics();
console.log(`Hits: ${metrics.hits}`);
console.log(`Misses: ${metrics.misses}`);
console.log(`Hit rate: ${metrics.hitRate}%`);
console.log(`Size: ${metrics.size} items`);
console.log(`Size bytes: ${metrics.sizeBytes}`);
```

### Cache Key Generation

Cache keys are deterministic SHA-256 hashes of:
- User message
- Data
- System prompt
- Model
- Temperature
- Max tokens
- Tools
- MCP servers
- Skills
- Response format schema

Identical inputs always produce identical keys.

### Disable Cache for Specific Call

```typescript
const result = await agent.prompt(prompt, {
  disableCache: true,
});
```

### Clear Cache

```typescript
import { defaultCache } from 'groundswell';

await defaultCache.clear();

// Or bust by prefix (agent ID)
await defaultCache.bustPrefix(agent.id);
```

### Cache Configuration

```typescript
import { LLMCache } from 'groundswell';

const customCache = new LLMCache({
  maxItems: 500,           // Default: 1000
  maxSizeBytes: 25_000_000, // Default: 50MB
  defaultTTLMs: 7_200_000,  // Default: 1 hour
});
```

## API Reference

### Agent Class

```typescript
class Agent {
  readonly id: string;
  readonly name: string;

  constructor(config?: AgentConfig);

  prompt<T>(prompt: Prompt<T>, overrides?: PromptOverrides): Promise<T>;
  promptWithMetadata<T>(prompt: Prompt<T>, overrides?: PromptOverrides): Promise<PromptResult<T>>;
  reflect<T>(prompt: Prompt<T>, overrides?: PromptOverrides): Promise<T>;
}
```

### Factory Function

```typescript
function createAgent(config?: AgentConfig): Agent;
```

### PromptOverrides

```typescript
interface PromptOverrides {
  system?: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  enableReflection?: boolean;
  disableCache?: boolean;
}
```

### Types

```typescript
interface Tool {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, unknown>;
    required?: string[];
  };
}

interface MCPServer {
  name: string;
  transport: 'inprocess' | 'stdio' | 'http';
  tools?: Tool[];
}

interface Skill {
  name: string;
  path: string;
}

interface AgentHooks {
  preToolUse?: Array<(ctx: PreToolUseContext) => Promise<void>>;
  postToolUse?: Array<(ctx: PostToolUseContext) => Promise<void>>;
  sessionStart?: Array<(ctx: SessionStartContext) => Promise<void>>;
  sessionEnd?: Array<(ctx: SessionEndContext) => Promise<void>>;
}
```

See [examples/08-sdk-features.ts](../examples/examples/08-sdk-features.ts) for tools and hooks usage.


================================================================================
DOCUMENTATION: PROMPT
File: docs/prompt.md
================================================================================

# Prompts

Prompts are immutable value objects that define what to send to an agent and how to validate the response using Zod schemas.

## Table of Contents

- [Basic Usage](#basic-usage)
- [Configuration](#configuration)
- [Response Format](#response-format)
- [Data Injection](#data-injection)
- [Overrides](#overrides)
- [Validation](#validation)
- [API Reference](#api-reference)

## Basic Usage

```typescript
import { createPrompt } from 'groundswell';
import { z } from 'zod';

const prompt = createPrompt({
  user: 'Analyze this code for bugs',
  data: { code: 'function foo() { return 42; }' },
  responseFormat: z.object({
    bugs: z.array(z.string()),
    severity: z.enum(['low', 'medium', 'high']),
  }),
});
```

## Configuration

### PromptConfig

```typescript
interface PromptConfig<T> {
  user: string;                           // Required: user message
  data?: Record<string, unknown>;         // Optional: structured data
  responseFormat: z.ZodType<T>;           // Required: response schema
  system?: string;                        // Optional: system prompt override
  tools?: Tool[];                         // Optional: tools override
  mcps?: MCPServer[];                     // Optional: MCPs override
  skills?: Skill[];                       // Optional: skills override
  hooks?: AgentHooks;                     // Optional: hooks override
  enableReflection?: boolean;             // Optional: enable reflection
}
```

### Creating Prompts

```typescript
// Factory function
const prompt = createPrompt({
  user: 'Hello',
  responseFormat: z.object({ response: z.string() }),
});

// Class constructor
const prompt = new Prompt({
  user: 'Hello',
  responseFormat: z.object({ response: z.string() }),
});
```

## Response Format

### Zod Schema Integration

The `responseFormat` property accepts any Zod schema. The schema:
- Defines the expected response type
- Enables compile-time type inference for `T`
- Validates API responses at runtime

```typescript
import { z } from 'zod';

// Simple object
const simpleSchema = z.object({
  answer: z.string(),
  confidence: z.number(),
});

// With constraints
const strictSchema = z.object({
  answer: z.string().min(10),
  confidence: z.number().min(0).max(1),
  reasoning: z.string().optional(),
});

// With descriptions (used for API hints)
const describedSchema = z.object({
  summary: z.string().describe('Brief summary in 2-3 sentences'),
  keyPoints: z.array(z.string()).describe('Main takeaways'),
  score: z.number().min(0).max(100).describe('Quality score'),
});

// Enums
const enumSchema = z.object({
  category: z.enum(['bug', 'feature', 'improvement']),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
});

// Nested objects
const nestedSchema = z.object({
  analysis: z.object({
    issues: z.array(z.object({
      line: z.number(),
      message: z.string(),
      severity: z.enum(['error', 'warning', 'info']),
    })),
    summary: z.string(),
  }),
});
```

### Type Inference

The prompt's response type is inferred from the schema:

```typescript
const prompt = createPrompt({
  user: 'Analyze',
  responseFormat: z.object({
    bugs: z.array(z.string()),
    score: z.number(),
  }),
});

// prompt is Prompt<{ bugs: string[], score: number }>

const result = await agent.prompt(prompt);
// result is { bugs: string[], score: number }
```

## Data Injection

### Data Property

Structured data is injected into the user message:

```typescript
const prompt = createPrompt({
  user: 'Analyze the following code for security issues',
  data: {
    code: 'const x = eval(userInput);',
    language: 'javascript',
  },
  responseFormat: analysisSchema,
});
```

The data is formatted as XML-like sections:

```
Analyze the following code for security issues

<code>
"const x = eval(userInput);"
</code>

<language>
"javascript"
</language>
```

### withData()

Create a new prompt with updated data (immutable):

```typescript
const basePrompt = createPrompt({
  user: 'Classify this item',
  responseFormat: classificationSchema,
});

// Create variations
const applePrompt = basePrompt.withData({ item: 'apple' });
const bananaPrompt = basePrompt.withData({ item: 'banana' });

// Data is merged
const prompt = basePrompt
  .withData({ item: 'apple' })
  .withData({ context: 'grocery store' });
// Data: { item: 'apple', context: 'grocery store' }
```

## Overrides

### System Prompt Override

```typescript
const prompt = createPrompt({
  user: 'Translate to French',
  system: 'You are a professional translator. Be precise and formal.',
  responseFormat: z.object({ translation: z.string() }),
});
```

### Tools Override

```typescript
const prompt = createPrompt({
  user: 'Calculate 2 + 2',
  tools: [calculatorTool],  // Only these tools available
  responseFormat: z.object({ result: z.number() }),
});
```

### Hooks Override

```typescript
const prompt = createPrompt({
  user: 'Process data',
  hooks: {
    preToolUse: [async (ctx) => console.log('Using tool:', ctx.toolName)],
  },
  responseFormat: z.object({ processed: z.boolean() }),
});
```

### Reflection Override

```typescript
const prompt = createPrompt({
  user: 'Complex analysis',
  enableReflection: true,  // Enable for this prompt
  responseFormat: analysisSchema,
});
```

## Validation

### validateResponse()

Validates data and throws on failure:

```typescript
try {
  const validated = prompt.validateResponse(parsed);
  // validated is T
} catch (error) {
  // error is ZodError with detailed validation info
  console.log(error.issues);
}
```

### safeValidateResponse()

Non-throwing validation:

```typescript
const result = prompt.safeValidateResponse(parsed);

if (result.success) {
  console.log(result.data);  // Type: T
} else {
  console.log(result.error.issues);  // Validation errors
}
```

### Validation Errors

ZodError provides detailed error information:

```typescript
const result = prompt.safeValidateResponse({ score: 'invalid' });

if (!result.success) {
  for (const issue of result.error.issues) {
    console.log(`Path: ${issue.path.join('.')}`);
    console.log(`Message: ${issue.message}`);
    console.log(`Code: ${issue.code}`);
  }
}
```

## API Reference

### Prompt Class

```typescript
class Prompt<T> {
  readonly id: string;
  readonly user: string;
  readonly data: Record<string, unknown>;
  readonly responseFormat: z.ZodType<T>;
  readonly systemOverride?: string;
  readonly toolsOverride?: Tool[];
  readonly mcpsOverride?: MCPServer[];
  readonly skillsOverride?: Skill[];
  readonly hooksOverride?: AgentHooks;
  readonly enableReflection?: boolean;

  constructor(config: PromptConfig<T>);

  validateResponse(data: unknown): T;
  safeValidateResponse(data: unknown):
    | { success: true; data: T }
    | { success: false; error: z.ZodError };
  buildUserMessage(): string;
  withData(newData: Record<string, unknown>): Prompt<T>;
  getData(): Record<string, unknown>;
  getResponseFormat(): z.ZodType<T>;
}
```

### Factory Function

```typescript
function createPrompt<T>(config: PromptConfig<T>): Prompt<T>;
```

### Immutability

Prompts are frozen on creation:

```typescript
const prompt = createPrompt({
  user: 'Hello',
  data: { key: 'value' },
  responseFormat: schema,
});

// These throw errors:
prompt.user = 'Modified';  // Error
prompt.data.key = 'new';   // Error (data is also frozen)

// Use withData() to create variations:
const newPrompt = prompt.withData({ key: 'new' });
```

### Usage with Agents

```typescript
import { createAgent, createPrompt } from 'groundswell';
import { z } from 'zod';

const agent = createAgent({ enableCache: true });

const prompt = createPrompt({
  user: 'Summarize',
  data: { text: longDocument },
  responseFormat: z.object({
    summary: z.string(),
    wordCount: z.number(),
  }),
});

// Simple execution
const result = await agent.prompt(prompt);

// With metadata
const { data, usage, duration } = await agent.promptWithMetadata(prompt);

// With reflection
const reflected = await agent.reflect(prompt);
```

### Common Patterns

**Reusable Base Prompts:**

```typescript
const classifyPrompt = createPrompt({
  user: 'Classify the following item into a category',
  responseFormat: z.object({
    category: z.string(),
    confidence: z.number(),
  }),
});

// Reuse with different items
for (const item of items) {
  const result = await agent.prompt(classifyPrompt.withData({ item }));
}
```

**Schema Libraries:**

```typescript
// schemas.ts
export const AnalysisSchema = z.object({
  summary: z.string(),
  issues: z.array(z.object({
    severity: z.enum(['low', 'medium', 'high']),
    description: z.string(),
  })),
});

export const ClassificationSchema = z.object({
  category: z.string(),
  confidence: z.number().min(0).max(1),
});

// usage.ts
import { AnalysisSchema, ClassificationSchema } from './schemas';

const analysisPrompt = createPrompt({
  user: 'Analyze',
  responseFormat: AnalysisSchema,
});
```

**Conditional Prompts:**

```typescript
function createAnalysisPrompt(options: { detailed: boolean }) {
  return createPrompt({
    user: options.detailed
      ? 'Provide a detailed analysis with examples'
      : 'Provide a brief analysis',
    responseFormat: options.detailed
      ? detailedSchema
      : briefSchema,
  });
}
```

See [examples/09-reflection.ts](../examples/examples/09-reflection.ts) for prompt validation and reflection patterns.


================================================================================
EXAMPLES OVERVIEW
File: examples/README.md
================================================================================

# Groundswell Workflow Engine - Examples

Comprehensive examples showcasing all features and configuration options of the Groundswell hierarchical workflow engine.

## Quick Start

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Run all examples
npm run start:all

# Or run individual examples
npm run start:basic
npm run start:decorators
npm run start:parent-child
npm run start:observers
npm run start:errors
npm run start:concurrent
npm run start:agent-loops
npm run start:sdk-features
npm run start:reflection
npm run start:introspection
```

## Examples Overview

### 1. Basic Workflow (`01-basic-workflow.ts`)

Core workflow concepts:
- Creating workflows by extending `Workflow` base class
- Using `WorkflowLogger` for structured logging
- Managing workflow status (`idle` → `running` → `completed`/`failed`)
- Using `WorkflowTreeDebugger` for visualization

### 2. Decorator Options (`02-decorator-options.ts`)

All decorator configuration options:

**@Step options:**
- `name` - Custom step name (defaults to method name)
- `snapshotState` - Capture state after step completion
- `trackTiming` - Track and emit step duration
- `logStart` - Log message at step start
- `logFinish` - Log message at step end

**@Task options:**
- `name` - Custom task name
- `concurrent` - Run returned workflows concurrently

**@ObservedState options:**
- `hidden` - Exclude from state snapshots
- `redact` - Show as `***` in snapshots (for sensitive data)

### 3. Parent-Child Workflows (`03-parent-child.ts`)

Hierarchical workflow structures:
- Multi-level workflow hierarchies
- Automatic parent-child attachment
- `@Task` decorator for spawning child workflows
- Event propagation from children to root
- Tree visualization of nested structures

### 4. Observers & Debugger (`04-observers-debugger.ts`)

Real-time monitoring and debugging:
- Implementing custom `WorkflowObserver`
- `MetricsObserver` for collecting statistics
- `ConsoleObserver` for real-time logging
- `Observable` event stream subscription
- `WorkflowTreeDebugger` complete API

### 5. Error Handling (`05-error-handling.ts`)

Error management patterns:
- `WorkflowError` structure with full context
- State snapshots preserved at error time
- Error events emitted to observers
- Retry patterns with backoff
- Error isolation in parent-child workflows

### 6. Concurrent Tasks (`06-concurrent-tasks.ts`)

Parallel execution patterns:
- Sequential vs concurrent comparison
- `@Task({ concurrent: true })` option
- Manual `Promise.all` patterns
- Fan-out / fan-in architecture
- Performance benchmarks

### 7. Agent Loops with Observability (`07-agent-loops.ts`)

Run: `npx tsx examples/examples/07-agent-loops.ts`

Agent.prompt() within workflow loops:
- Using Agent.prompt() within ctx.step() loops
- Multiple agents for different item types
- Full event tree visualization with timing
- State snapshots at each iteration
- Cache hit/miss tracking

### 8. SDK Features Integration (`08-sdk-features.ts`)

Run: `npx tsx examples/examples/08-sdk-features.ts`

Anthropic SDK integration:
- Custom tool definitions with handlers
- MCP server configuration (inprocess)
- Pre/Post tool hooks for logging and validation
- Skills integration with system prompt content
- Environment variable pass-through

### 9. Multi-level Reflection (`09-reflection.ts`)

Run: `npx tsx examples/examples/09-reflection.ts`

Reflection at all three levels:
- Prompt-level reflection (enableReflection on prompt)
- Agent-level reflection (agent.reflect() method)
- Workflow-level reflection (step failure retry)
- Reflection events in tree output
- Error recovery with revised prompts

### 10. Introspection Tools Demo (`10-introspection.ts`)

Run: `npx tsx examples/examples/10-introspection.ts`

Agent self-awareness and hierarchy navigation:
- inspect_current_node - "Where am I?"
- read_ancestor_chain - "What's above me?"
- list_siblings_children - "What's around me?"
- inspect_prior_outputs - "What happened before?"
- inspect_cache_status - "Is this cached?"
- request_spawn_workflow - "Can I create children?"

## Project Structure

```
examples/
├── examples/
│   ├── 01-basic-workflow.ts
│   ├── 02-decorator-options.ts
│   ├── 03-parent-child.ts
│   ├── 04-observers-debugger.ts
│   ├── 05-error-handling.ts
│   ├── 06-concurrent-tasks.ts
│   ├── 07-agent-loops.ts
│   ├── 08-sdk-features.ts
│   ├── 09-reflection.ts
│   └── 10-introspection.ts
├── utils/
│   └── helpers.ts
├── index.ts
└── README.md
```

## Key Concepts

### Workflow Status Lifecycle

```
idle → running → completed
                ↘ failed
                ↘ cancelled
```

### Event Types

| Event Type | Description |
|------------|-------------|
| `stepStart` | Step execution started |
| `stepEnd` | Step completed (includes duration) |
| `taskStart` | Task execution started |
| `taskEnd` | Task completed |
| `childAttached` | Child workflow attached to parent |
| `stateSnapshot` | State snapshot captured |
| `error` | Error occurred |
| `treeUpdated` | Tree structure changed |

### Tree Visualization Symbols

| Symbol | Status |
|--------|--------|
| ○ | idle |
| ◐ | running |
| ✓ | completed |
| ✗ | failed |
| ⊘ | cancelled |

## Usage Patterns

### Basic Workflow
```typescript
class MyWorkflow extends Workflow {
  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting workflow');
    // ... workflow logic
    this.setStatus('completed');
  }
}
```

### Step with All Options
```typescript
@Step({
  name: 'CustomStepName',
  snapshotState: true,
  trackTiming: true,
  logStart: true,
  logFinish: true,
})
async myStep(): Promise<void> {
  // Step logic
}
```

### Observable State
```typescript
@ObservedState()
publicField: string = 'visible';

@ObservedState({ redact: true })
apiKey: string = 'secret';

@ObservedState({ hidden: true })
internalState: object = {};
```

### Concurrent Child Workflows
```typescript
@Task({ concurrent: true })
async createWorkers(): Promise<WorkerWorkflow[]> {
  return items.map(item => new WorkerWorkflow(item, this));
}
```

## License

MIT


================================================================================
EXAMPLE: EXAMPLE 1: BASIC WORKFLOW
File: examples/examples/01-basic-workflow.ts
================================================================================

/**
 * Example 1: Basic Workflow
 *
 * Demonstrates:
 * - Creating a simple workflow by extending the Workflow base class
 * - Using the logger for structured logging
 * - Managing workflow status (idle -> running -> completed/failed)
 * - Basic execution flow
 */

import { Workflow, WorkflowTreeDebugger } from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

/**
 * A simple data processing workflow
 */
class DataProcessingWorkflow extends Workflow {
  private data: string[] = [];

  async run(): Promise<string[]> {
    this.setStatus('running');
    this.logger.info('Starting data processing workflow');

    try {
      // Step 1: Load data
      this.logger.info('Loading data...');
      await this.loadData();

      // Step 2: Process data
      this.logger.info('Processing data...');
      await this.processData();

      // Step 3: Save results
      this.logger.info('Saving results...');
      await this.saveResults();

      this.setStatus('completed');
      this.logger.info('Workflow completed successfully');
      return this.data;
    } catch (error) {
      this.setStatus('failed');
      this.logger.error('Workflow failed', { error });
      throw error;
    }
  }

  private async loadData(): Promise<void> {
    await sleep(100);
    this.data = ['item1', 'item2', 'item3'];
    this.logger.debug('Loaded items', { count: this.data.length });
  }

  private async processData(): Promise<void> {
    await sleep(150);
    this.data = this.data.map((item) => item.toUpperCase());
    this.logger.debug('Processed items', { data: this.data });
  }

  private async saveResults(): Promise<void> {
    await sleep(50);
    this.logger.debug('Results saved');
  }
}

/**
 * Run the basic workflow example
 */
export async function runBasicWorkflowExample(): Promise<void> {
  printHeader('Example 1: Basic Workflow');

  // Create workflow with custom name
  const workflow = new DataProcessingWorkflow('DataProcessor');

  // Attach debugger to visualize
  const debugger_ = new WorkflowTreeDebugger(workflow);

  printSection('Initial State');
  console.log('Workflow ID:', workflow.id);
  console.log('Status:', workflow.status);
  console.log('Tree:\n' + debugger_.toTreeString());

  printSection('Running Workflow');
  const result = await workflow.run();

  printSection('Final State');
  console.log('Status:', workflow.status);
  console.log('Result:', result);
  console.log('\nTree:\n' + debugger_.toTreeString());

  printSection('Logs');
  console.log(debugger_.toLogString());

  printSection('Statistics');
  console.log(debugger_.getStats());
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runBasicWorkflowExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 2: DECORATOR OPTIONS
File: examples/examples/02-decorator-options.ts
================================================================================

/**
 * Example 2: Decorator Options
 *
 * Demonstrates all decorator configuration options:
 *
 * @Step options:
 * - name: Custom step name (defaults to method name)
 * - snapshotState: Capture state snapshot after step completion
 * - trackTiming: Track and emit step duration
 * - logStart: Log message at step start
 * - logFinish: Log message at step end
 *
 * @Task options:
 * - name: Custom task name
 * - concurrent: Run returned workflows concurrently
 *
 * @ObservedState options:
 * - hidden: Field not included in snapshots
 * - redact: Value shown as '***' in snapshots
 */

import {
  Workflow,
  Step,
  Task,
  ObservedState,
  getObservedState,
  WorkflowTreeDebugger,
  WorkflowObserver,
  WorkflowEvent,
  LogEntry,
  WorkflowNode,
} from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

/**
 * Workflow demonstrating all @Step decorator options
 */
class StepOptionsWorkflow extends Workflow {
  @ObservedState()
  currentPhase: string = 'init';

  @ObservedState()
  itemsProcessed: number = 0;

  // Default step - minimal configuration
  @Step()
  async defaultStep(): Promise<void> {
    this.currentPhase = 'default';
    await sleep(50);
  }

  // Step with custom name
  @Step({ name: 'CustomNamedStep' })
  async stepWithCustomName(): Promise<void> {
    this.currentPhase = 'custom-named';
    await sleep(50);
  }

  // Step with state snapshot
  @Step({ snapshotState: true })
  async stepWithSnapshot(): Promise<void> {
    this.currentPhase = 'snapshot';
    this.itemsProcessed = 10;
    await sleep(50);
    // State will be captured after this step
  }

  // Step with timing tracking
  @Step({ trackTiming: true })
  async stepWithTiming(): Promise<void> {
    this.currentPhase = 'timed';
    await sleep(200); // Longer delay to show timing
  }

  // Step with start/finish logging
  @Step({ logStart: true, logFinish: true })
  async stepWithLogging(): Promise<void> {
    this.currentPhase = 'logged';
    this.logger.info('Inside the step - this is custom logging');
    await sleep(50);
  }

  // Step with ALL options enabled
  @Step({
    name: 'FullyConfiguredStep',
    snapshotState: true,
    trackTiming: true,
    logStart: true,
    logFinish: true,
  })
  async fullyConfiguredStep(): Promise<void> {
    this.currentPhase = 'fully-configured';
    this.itemsProcessed = 100;
    await sleep(100);
  }

  async run(): Promise<void> {
    this.setStatus('running');

    await this.defaultStep();
    await this.stepWithCustomName();
    await this.stepWithSnapshot();
    await this.stepWithTiming();
    await this.stepWithLogging();
    await this.fullyConfiguredStep();

    this.setStatus('completed');
  }
}

/**
 * Workflow demonstrating @ObservedState options
 */
class StateOptionsWorkflow extends Workflow {
  // Regular observed state - included in snapshots
  @ObservedState()
  publicData: string = 'visible-value';

  // Redacted state - shows as '***' in snapshots
  @ObservedState({ redact: true })
  apiKey: string = 'super-secret-api-key-12345';

  // Another redacted field
  @ObservedState({ redact: true })
  password: string = 'my-password';

  // Hidden state - completely excluded from snapshots
  @ObservedState({ hidden: true })
  internalCounter: number = 0;

  // Another hidden field
  @ObservedState({ hidden: true })
  debugInfo: object = { internal: true };

  // Multiple observed fields for demonstration
  @ObservedState()
  processingStatus: string = 'pending';

  @ObservedState()
  progress: number = 0;

  async run(): Promise<void> {
    this.setStatus('running');
    this.processingStatus = 'processing';
    this.progress = 50;
    this.internalCounter = 999; // This won't appear in snapshots
    await sleep(50);
    this.processingStatus = 'done';
    this.progress = 100;
    this.setStatus('completed');
  }
}

/**
 * Run the decorator options example
 */
export async function runDecoratorOptionsExample(): Promise<void> {
  printHeader('Example 2: Decorator Options');

  // Part 1: @Step options
  printSection('@Step Decorator Options');

  const stepWorkflow = new StepOptionsWorkflow('StepOptions');
  const events: WorkflowEvent[] = [];

  // Custom observer to capture events
  const observer: WorkflowObserver = {
    onLog: (entry: LogEntry) => {
      console.log(`  [LOG] ${entry.level.toUpperCase()}: ${entry.message}`);
    },
    onEvent: (event: WorkflowEvent) => {
      events.push(event);
      if (event.type === 'stepStart') {
        console.log(`  [EVENT] Step started: ${event.step}`);
      } else if (event.type === 'stepEnd') {
        console.log(`  [EVENT] Step ended: ${event.step} (${event.duration}ms)`);
      } else if (event.type === 'stateSnapshot') {
        console.log(`  [EVENT] State snapshot captured`);
      }
    },
    onStateUpdated: () => {},
    onTreeChanged: () => {},
  };

  stepWorkflow.addObserver(observer);
  await stepWorkflow.run();

  console.log('\nStep events captured:', events.filter((e) => e.type.includes('step')).length);

  // Part 2: @ObservedState options
  printSection('@ObservedState Decorator Options');

  const stateWorkflow = new StateOptionsWorkflow('StateOptions');
  await stateWorkflow.run();

  console.log('Actual field values:');
  console.log('  publicData:', stateWorkflow.publicData);
  console.log('  apiKey:', stateWorkflow.apiKey);
  console.log('  password:', stateWorkflow.password);
  console.log('  internalCounter:', (stateWorkflow as any).internalCounter);
  console.log('  processingStatus:', stateWorkflow.processingStatus);
  console.log('  progress:', stateWorkflow.progress);

  console.log('\nState snapshot (via getObservedState):');
  const snapshot = getObservedState(stateWorkflow);
  console.log(JSON.stringify(snapshot, null, 2));

  console.log('\nNote:');
  console.log('  - apiKey and password show as "***" (redacted)');
  console.log('  - internalCounter and debugInfo are not present (hidden)');
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runDecoratorOptionsExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 3: PARENT CHILD
File: examples/examples/03-parent-child.ts
================================================================================

/**
 * Example 3: Parent-Child Workflows
 *
 * Demonstrates:
 * - Creating hierarchical workflow structures
 * - Automatic parent-child attachment
 * - Using @Task decorator to spawn child workflows
 * - Event propagation from children to root
 * - Tree visualization of nested workflows
 */

import {
  Workflow,
  Step,
  Task,
  ObservedState,
  WorkflowTreeDebugger,
} from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

/**
 * Leaf workflow - performs actual work
 */
class ProcessItemWorkflow extends Workflow {
  @ObservedState()
  itemId: string;

  @ObservedState()
  processed: boolean = false;

  constructor(itemId: string, parent?: Workflow) {
    super(`ProcessItem-${itemId}`, parent);
    this.itemId = itemId;
  }

  @Step({ trackTiming: true, snapshotState: true })
  async validate(): Promise<void> {
    this.logger.info(`Validating item ${this.itemId}`);
    await sleep(50);
  }

  @Step({ trackTiming: true, snapshotState: true })
  async transform(): Promise<void> {
    this.logger.info(`Transforming item ${this.itemId}`);
    await sleep(100);
  }

  @Step({ trackTiming: true, snapshotState: true })
  async save(): Promise<void> {
    this.logger.info(`Saving item ${this.itemId}`);
    this.processed = true;
    await sleep(50);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info(`Starting item processing for ${this.itemId}`);

    await this.validate();
    await this.transform();
    await this.save();

    this.setStatus('completed');
    this.logger.info(`Completed processing ${this.itemId}`);
  }
}

/**
 * Middle-tier workflow - manages a batch of items
 */
class BatchProcessorWorkflow extends Workflow {
  @ObservedState()
  batchId: string;

  @ObservedState()
  itemCount: number = 0;

  @ObservedState()
  processedCount: number = 0;

  private items: string[];

  constructor(batchId: string, items: string[], parent?: Workflow) {
    super(`Batch-${batchId}`, parent);
    this.batchId = batchId;
    this.items = items;
    this.itemCount = items.length;
  }

  @Step({ logStart: true })
  async prepareBatch(): Promise<void> {
    this.logger.info(`Preparing batch ${this.batchId} with ${this.itemCount} items`);
    await sleep(50);
  }

  @Task()
  async processItem(itemId: string): Promise<ProcessItemWorkflow> {
    this.logger.info(`Spawning workflow for item ${itemId}`);
    return new ProcessItemWorkflow(itemId, this);
  }

  @Step({ logFinish: true, snapshotState: true })
  async finalizeBatch(): Promise<void> {
    this.processedCount = this.itemCount;
    this.logger.info(`Batch ${this.batchId} finalized: ${this.processedCount} items processed`);
    await sleep(30);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info(`Starting batch ${this.batchId}`);

    await this.prepareBatch();

    // Process each item sequentially
    for (const itemId of this.items) {
      const itemWorkflow = await this.processItem(itemId);
      await itemWorkflow.run();
      this.processedCount++;
    }

    await this.finalizeBatch();

    this.setStatus('completed');
  }
}

/**
 * Top-level orchestrator workflow
 */
class DataPipelineWorkflow extends Workflow {
  @ObservedState()
  pipelineName: string;

  @ObservedState()
  totalBatches: number = 0;

  @ObservedState()
  completedBatches: number = 0;

  private batches: { id: string; items: string[] }[];

  constructor(name: string, batches: { id: string; items: string[] }[]) {
    super(name);
    this.pipelineName = name;
    this.batches = batches;
    this.totalBatches = batches.length;
  }

  @Step({ logStart: true, logFinish: true })
  async initialize(): Promise<void> {
    this.logger.info(`Initializing pipeline: ${this.pipelineName}`);
    this.logger.info(`Total batches to process: ${this.totalBatches}`);
    await sleep(50);
  }

  @Task()
  async processBatch(batch: { id: string; items: string[] }): Promise<BatchProcessorWorkflow> {
    this.logger.info(`Creating batch processor for ${batch.id}`);
    return new BatchProcessorWorkflow(batch.id, batch.items, this);
  }

  @Step({ logStart: true, logFinish: true, snapshotState: true })
  async cleanup(): Promise<void> {
    this.logger.info('Running cleanup tasks');
    await sleep(50);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('=== Pipeline Started ===');

    await this.initialize();

    // Process each batch
    for (const batch of this.batches) {
      const batchWorkflow = await this.processBatch(batch);
      await batchWorkflow.run();
      this.completedBatches++;
      this.logger.info(`Completed ${this.completedBatches}/${this.totalBatches} batches`);
    }

    await this.cleanup();

    this.setStatus('completed');
    this.logger.info('=== Pipeline Completed ===');
  }
}

/**
 * Run the parent-child workflow example
 */
export async function runParentChildExample(): Promise<void> {
  printHeader('Example 3: Parent-Child Workflows');

  // Create sample data
  const batches = [
    { id: 'batch-A', items: ['A1', 'A2'] },
    { id: 'batch-B', items: ['B1', 'B2', 'B3'] },
  ];

  // Create the pipeline
  const pipeline = new DataPipelineWorkflow('MyDataPipeline', batches);
  const debugger_ = new WorkflowTreeDebugger(pipeline);

  printSection('Initial Tree Structure');
  console.log(debugger_.toTreeString());

  printSection('Executing Pipeline');
  await pipeline.run();

  printSection('Final Tree Structure');
  console.log(debugger_.toTreeString());

  printSection('Tree Statistics');
  const stats = debugger_.getStats();
  console.log(`Total nodes: ${stats.totalNodes}`);
  console.log(`By status:`, stats.byStatus);
  console.log(`Total logs: ${stats.totalLogs}`);
  console.log(`Total events: ${stats.totalEvents}`);

  printSection('Workflow Hierarchy');
  console.log('Pipeline:', pipeline.id);
  console.log('  Children (batches):', pipeline.children.length);
  for (const batch of pipeline.children) {
    console.log(`    ${batch.getNode().name} - ${batch.children.length} items`);
    for (const item of batch.children) {
      console.log(`      ${item.getNode().name} [${item.getNode().status}]`);
    }
  }

  printSection('Sample Logs (first 15)');
  const logLines = debugger_.toLogString().split('\n').slice(0, 15);
  console.log(logLines.join('\n'));
  console.log('...');
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runParentChildExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 4: OBSERVERS DEBUGGER
File: examples/examples/04-observers-debugger.ts
================================================================================

/**
 * Example 4: Observers and Debugger
 *
 * Demonstrates:
 * - Implementing custom WorkflowObserver
 * - Real-time event streaming
 * - Log collection and filtering
 * - Using WorkflowTreeDebugger API
 * - Observable subscription patterns
 */

import {
  Workflow,
  Step,
  Task,
  ObservedState,
  WorkflowTreeDebugger,
  WorkflowObserver,
  WorkflowEvent,
  LogEntry,
  WorkflowNode,
  Observable,
} from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

/**
 * Custom observer that collects detailed metrics
 */
class MetricsObserver implements WorkflowObserver {
  public logCount = 0;
  public eventCount = 0;
  public stateUpdates = 0;
  public treeChanges = 0;

  public logsByLevel: Record<string, number> = {
    debug: 0,
    info: 0,
    warn: 0,
    error: 0,
  };

  public eventsByType: Record<string, number> = {};
  public stepDurations: { step: string; duration: number }[] = [];
  public errors: WorkflowEvent[] = [];

  onLog(entry: LogEntry): void {
    this.logCount++;
    this.logsByLevel[entry.level] = (this.logsByLevel[entry.level] || 0) + 1;
  }

  onEvent(event: WorkflowEvent): void {
    this.eventCount++;
    this.eventsByType[event.type] = (this.eventsByType[event.type] || 0) + 1;

    if (event.type === 'stepEnd') {
      this.stepDurations.push({
        step: event.step,
        duration: event.duration,
      });
    }

    if (event.type === 'error') {
      this.errors.push(event);
    }
  }

  onStateUpdated(_node: WorkflowNode): void {
    this.stateUpdates++;
  }

  onTreeChanged(_root: WorkflowNode): void {
    this.treeChanges++;
  }

  getReport(): string {
    const lines = [
      `=== Metrics Report ===`,
      `Logs: ${this.logCount} total`,
      `  - debug: ${this.logsByLevel.debug}`,
      `  - info: ${this.logsByLevel.info}`,
      `  - warn: ${this.logsByLevel.warn}`,
      `  - error: ${this.logsByLevel.error}`,
      ``,
      `Events: ${this.eventCount} total`,
      ...Object.entries(this.eventsByType).map(([type, count]) => `  - ${type}: ${count}`),
      ``,
      `State updates: ${this.stateUpdates}`,
      `Tree changes: ${this.treeChanges}`,
      ``,
      `Step durations:`,
      ...this.stepDurations.map((s) => `  - ${s.step}: ${s.duration}ms`),
    ];

    if (this.errors.length > 0) {
      lines.push(``, `Errors: ${this.errors.length}`);
    }

    return lines.join('\n');
  }
}

/**
 * Custom observer that logs in real-time
 */
class ConsoleObserver implements WorkflowObserver {
  private prefix: string;

  constructor(prefix: string = 'OBSERVER') {
    this.prefix = prefix;
  }

  onLog(entry: LogEntry): void {
    const level = entry.level.toUpperCase().padEnd(5);
    console.log(`[${this.prefix}] ${level} | ${entry.message}`);
  }

  onEvent(event: WorkflowEvent): void {
    if (event.type === 'stepStart') {
      console.log(`[${this.prefix}] >> Step started: ${event.step}`);
    } else if (event.type === 'stepEnd') {
      console.log(`[${this.prefix}] << Step ended: ${event.step} (${event.duration}ms)`);
    } else if (event.type === 'childAttached') {
      console.log(`[${this.prefix}] ++ Child attached: ${event.child.name}`);
    } else if (event.type === 'error') {
      console.log(`[${this.prefix}] !! ERROR: ${event.error.message}`);
    }
  }

  onStateUpdated(node: WorkflowNode): void {
    console.log(`[${this.prefix}] State updated: ${node.name}`);
  }

  onTreeChanged(_root: WorkflowNode): void {
    console.log(`[${this.prefix}] Tree structure changed`);
  }
}

/**
 * Sample workflow for observation
 */
class ObservableWorkflow extends Workflow {
  @ObservedState()
  phase: string = 'init';

  @ObservedState()
  progress: number = 0;

  @Step({ trackTiming: true, snapshotState: true, logStart: true })
  async phase1(): Promise<void> {
    this.phase = 'phase1';
    this.progress = 25;
    await sleep(100);
  }

  @Step({ trackTiming: true, snapshotState: true })
  async phase2(): Promise<void> {
    this.phase = 'phase2';
    this.progress = 50;
    await sleep(150);
  }

  @Step({ trackTiming: true, snapshotState: true })
  async phase3(): Promise<void> {
    this.phase = 'phase3';
    this.progress = 75;
    await sleep(80);
  }

  @Step({ trackTiming: true, snapshotState: true, logFinish: true })
  async phase4(): Promise<void> {
    this.phase = 'phase4';
    this.progress = 100;
    await sleep(120);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Observable workflow starting');

    await this.phase1();
    await this.phase2();
    await this.phase3();
    await this.phase4();

    this.setStatus('completed');
    this.logger.info('Observable workflow completed');
  }
}

/**
 * Child workflow for tree demonstration
 */
class ChildWorkflow extends Workflow {
  @Step({ trackTiming: true })
  async doWork(): Promise<void> {
    this.logger.info('Child doing work');
    await sleep(50);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    await this.doWork();
    this.setStatus('completed');
  }
}

/**
 * Parent workflow that spawns children
 */
class ParentWithChildrenWorkflow extends Workflow {
  @Task()
  async spawnChild(name: string): Promise<ChildWorkflow> {
    return new ChildWorkflow(name, this);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Parent starting');

    const child1 = await this.spawnChild('Child-1');
    await child1.run();

    const child2 = await this.spawnChild('Child-2');
    await child2.run();

    this.setStatus('completed');
    this.logger.info('Parent completed');
  }
}

/**
 * Run the observers and debugger example
 */
export async function runObserversDebuggerExample(): Promise<void> {
  printHeader('Example 4: Observers and Debugger');

  // Part 1: Custom MetricsObserver
  printSection('Part 1: MetricsObserver');
  {
    const workflow = new ObservableWorkflow('MetricsDemo');
    const metricsObserver = new MetricsObserver();
    workflow.addObserver(metricsObserver);

    await workflow.run();

    console.log(metricsObserver.getReport());
  }

  // Part 2: Real-time ConsoleObserver
  printSection('Part 2: Real-time ConsoleObserver');
  {
    const workflow = new ObservableWorkflow('ConsoleDemo');
    const consoleObserver = new ConsoleObserver('LIVE');
    workflow.addObserver(consoleObserver);

    await workflow.run();
  }

  // Part 3: Using Observable for event streaming
  printSection('Part 3: Observable Event Stream');
  {
    const workflow = new ParentWithChildrenWorkflow('StreamDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    const eventLog: string[] = [];

    // Subscribe to the event stream
    const subscription = debugger_.events.subscribe({
      next: (event) => {
        eventLog.push(`${event.type}: ${'node' in event ? event.node.name : 'N/A'}`);
      },
    });

    await workflow.run();

    console.log('Events received via Observable:');
    eventLog.forEach((e) => console.log(`  ${e}`));

    // Cleanup subscription
    subscription.unsubscribe();
  }

  // Part 4: WorkflowTreeDebugger API
  printSection('Part 4: WorkflowTreeDebugger API');
  {
    const workflow = new ParentWithChildrenWorkflow('DebuggerDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    await workflow.run();

    console.log('1. Tree visualization:');
    console.log(debugger_.toTreeString());

    console.log('2. Get tree root:');
    const root = debugger_.getTree();
    console.log(`   Root: ${root.name} (${root.id})`);
    console.log(`   Children: ${root.children.length}`);

    console.log('\n3. Find node by ID:');
    const firstChild = workflow.children[0];
    const foundNode = debugger_.getNode(firstChild.id);
    console.log(`   Found: ${foundNode?.name}`);

    console.log('\n4. Statistics:');
    const stats = debugger_.getStats();
    console.log(`   ${JSON.stringify(stats, null, 2)}`);

    console.log('\n5. Formatted logs:');
    const logs = debugger_.toLogString().split('\n').slice(0, 5);
    logs.forEach((log) => console.log(`   ${log}`));
    console.log('   ...');
  }

  // Part 5: Multiple observers
  printSection('Part 5: Multiple Observers');
  {
    const workflow = new ObservableWorkflow('MultiObserver');

    const metrics = new MetricsObserver();
    const console1 = new ConsoleObserver('OBS-1');
    const console2 = new ConsoleObserver('OBS-2');

    workflow.addObserver(metrics);
    workflow.addObserver(console1);
    workflow.addObserver(console2);

    // Note: both console observers will print
    console.log('Running with 3 observers attached...');
    await workflow.run();

    console.log('\nMetrics summary:');
    console.log(`  Events received: ${metrics.eventCount}`);
    console.log(`  Logs received: ${metrics.logCount}`);
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runObserversDebuggerExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 5: ERROR HANDLING
File: examples/examples/05-error-handling.ts
================================================================================

/**
 * Example 5: Error Handling
 *
 * Demonstrates:
 * - How @Step decorator wraps errors in WorkflowError
 * - Error context including state snapshots and logs
 * - Error events emitted to observers
 * - Error propagation in parent-child workflows
 * - Recovery strategies in workflow orchestration
 */

import {
  Workflow,
  Step,
  Task,
  ObservedState,
  getObservedState,
  WorkflowTreeDebugger,
  WorkflowObserver,
  WorkflowEvent,
  WorkflowError,
  LogEntry,
  WorkflowNode,
} from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

/**
 * Workflow that demonstrates error wrapping
 */
class ErrorDemoWorkflow extends Workflow {
  @ObservedState()
  currentStep: string = 'init';

  @ObservedState()
  itemsProcessed: number = 0;

  @ObservedState({ redact: true })
  sensitiveContext: string = 'secret-data';

  @Step({ snapshotState: true })
  async step1(): Promise<void> {
    this.currentStep = 'step1';
    this.itemsProcessed = 5;
    this.logger.info('Step 1 completed successfully');
    await sleep(50);
  }

  @Step({ snapshotState: true })
  async step2(): Promise<void> {
    this.currentStep = 'step2';
    this.itemsProcessed = 10;
    this.logger.info('Step 2 completed successfully');
    await sleep(50);
  }

  @Step({ snapshotState: true })
  async failingStep(): Promise<void> {
    this.currentStep = 'failing';
    this.logger.info('About to fail...');
    await sleep(30);

    // This error will be wrapped in WorkflowError
    throw new Error('Something went wrong in failingStep!');
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting error demo workflow');

    await this.step1();
    await this.step2();
    await this.failingStep(); // This will throw

    // This line won't be reached
    this.setStatus('completed');
  }
}

/**
 * Workflow with retry logic
 */
class RetryableWorkflow extends Workflow {
  @ObservedState()
  attempt: number = 0;

  @ObservedState()
  maxAttempts: number = 3;

  @ObservedState()
  success: boolean = false;

  private failUntilAttempt: number;

  constructor(name: string, failUntilAttempt: number = 2) {
    super(name);
    this.failUntilAttempt = failUntilAttempt;
  }

  @Step({ trackTiming: true, snapshotState: true })
  async unreliableOperation(): Promise<void> {
    this.attempt++;
    this.logger.info(`Attempt ${this.attempt}/${this.maxAttempts}`);
    await sleep(50);

    if (this.attempt < this.failUntilAttempt) {
      throw new Error(`Simulated failure on attempt ${this.attempt}`);
    }

    this.success = true;
    this.logger.info('Operation succeeded!');
  }

  async run(): Promise<boolean> {
    this.setStatus('running');
    this.logger.info('Starting retryable workflow');

    while (this.attempt < this.maxAttempts) {
      try {
        await this.unreliableOperation();
        this.setStatus('completed');
        return true;
      } catch (error) {
        const wfError = error as WorkflowError;
        this.logger.warn(`Attempt failed: ${wfError.message}`);

        if (this.attempt >= this.maxAttempts) {
          this.setStatus('failed');
          this.logger.error('All attempts exhausted');
          throw error;
        }

        this.logger.info('Retrying...');
        await sleep(100); // Backoff delay
      }
    }

    this.setStatus('failed');
    return false;
  }
}

/**
 * Child workflow that may fail
 */
class FailableChildWorkflow extends Workflow {
  private shouldFail: boolean;

  @ObservedState()
  taskStatus: string = 'pending';

  constructor(name: string, shouldFail: boolean, parent?: Workflow) {
    super(name, parent);
    this.shouldFail = shouldFail;
  }

  @Step({ snapshotState: true })
  async execute(): Promise<void> {
    this.taskStatus = 'executing';
    this.logger.info('Executing child workflow');
    await sleep(50);

    if (this.shouldFail) {
      throw new Error(`Child ${this.getNode().name} failed intentionally`);
    }

    this.taskStatus = 'success';
  }

  async run(): Promise<void> {
    this.setStatus('running');
    await this.execute();
    this.setStatus('completed');
  }
}

/**
 * Parent workflow with error recovery
 */
class ResilientParentWorkflow extends Workflow {
  @ObservedState()
  totalChildren: number = 0;

  @ObservedState()
  successfulChildren: number = 0;

  @ObservedState()
  failedChildren: number = 0;

  private childConfigs: { name: string; shouldFail: boolean }[];

  constructor(name: string, childConfigs: { name: string; shouldFail: boolean }[]) {
    super(name);
    this.childConfigs = childConfigs;
    this.totalChildren = childConfigs.length;
  }

  @Task()
  async spawnChild(config: { name: string; shouldFail: boolean }): Promise<FailableChildWorkflow> {
    return new FailableChildWorkflow(config.name, config.shouldFail, this);
  }

  async run(): Promise<{ success: number; failed: number }> {
    this.setStatus('running');
    this.logger.info(`Starting resilient parent with ${this.totalChildren} children`);

    for (const config of this.childConfigs) {
      const child = await this.spawnChild(config);

      try {
        await child.run();
        this.successfulChildren++;
        this.logger.info(`Child ${config.name} succeeded`);
      } catch (error) {
        this.failedChildren++;
        const wfError = error as WorkflowError;
        this.logger.warn(`Child ${config.name} failed: ${wfError.message}`);
        // Continue with other children instead of failing entirely
      }
    }

    const allSucceeded = this.failedChildren === 0;
    this.setStatus(allSucceeded ? 'completed' : 'completed'); // Still complete, but with partial success
    this.logger.info(`Completed: ${this.successfulChildren} succeeded, ${this.failedChildren} failed`);

    return {
      success: this.successfulChildren,
      failed: this.failedChildren,
    };
  }
}

/**
 * Run the error handling example
 */
export async function runErrorHandlingExample(): Promise<void> {
  printHeader('Example 5: Error Handling');

  // Part 1: Basic error wrapping
  printSection('Part 1: WorkflowError Structure');
  {
    const workflow = new ErrorDemoWorkflow('ErrorDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    let capturedError: WorkflowError | null = null;

    try {
      await workflow.run();
    } catch (error) {
      capturedError = error as WorkflowError;
    }

    console.log('Error caught and wrapped in WorkflowError:');
    console.log(`  message: ${capturedError?.message}`);
    console.log(`  workflowId: ${capturedError?.workflowId}`);
    console.log(`  stack: ${capturedError?.stack?.split('\n')[0]}...`);

    console.log('\nState snapshot at time of error:');
    console.log(JSON.stringify(capturedError?.state, null, 2));

    console.log('\nLogs at time of error:');
    capturedError?.logs.forEach((log) => {
      console.log(`  [${log.level}] ${log.message}`);
    });

    console.log('\nTree state after error:');
    console.log(debugger_.toTreeString());
  }

  // Part 2: Error events
  printSection('Part 2: Error Events');
  {
    const workflow = new ErrorDemoWorkflow('ErrorEvents');
    const errors: WorkflowEvent[] = [];

    const observer: WorkflowObserver = {
      onLog: () => {},
      onEvent: (event) => {
        if (event.type === 'error') {
          errors.push(event);
        }
      },
      onStateUpdated: () => {},
      onTreeChanged: () => {},
    };

    workflow.addObserver(observer);

    try {
      await workflow.run();
    } catch {
      // Expected
    }

    console.log(`Error events captured: ${errors.length}`);
    errors.forEach((e) => {
      if (e.type === 'error') {
        console.log(`  - Node: ${e.node.name}`);
        console.log(`    Message: ${e.error.message}`);
        console.log(`    State keys: ${Object.keys(e.error.state).join(', ')}`);
      }
    });
  }

  // Part 3: Retry logic
  printSection('Part 3: Retry Pattern');
  {
    console.log('Workflow that succeeds on 3rd attempt:');
    const workflow1 = new RetryableWorkflow('RetrySuccess', 3);

    try {
      const success = await workflow1.run();
      console.log(`  Result: ${success ? 'SUCCESS' : 'FAILED'}`);
      console.log(`  Attempts: ${workflow1.attempt}`);
    } catch {
      console.log('  Unexpected failure');
    }

    console.log('\nWorkflow that exhausts all retries:');
    const workflow2 = new RetryableWorkflow('RetryFail', 10); // Will never succeed

    try {
      await workflow2.run();
    } catch (error) {
      const wfError = error as WorkflowError;
      console.log(`  Failed after ${workflow2.attempt} attempts`);
      console.log(`  Final error: ${wfError.message}`);
    }
  }

  // Part 4: Parent-child error isolation
  printSection('Part 4: Error Isolation in Hierarchies');
  {
    const childConfigs = [
      { name: 'Child-A', shouldFail: false },
      { name: 'Child-B', shouldFail: true }, // This one will fail
      { name: 'Child-C', shouldFail: false },
      { name: 'Child-D', shouldFail: true }, // This one will fail
      { name: 'Child-E', shouldFail: false },
    ];

    const workflow = new ResilientParentWorkflow('ResilientParent', childConfigs);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    const result = await workflow.run();

    console.log('Result:', result);
    console.log('\nTree visualization:');
    console.log(debugger_.toTreeString());

    console.log('Child statuses:');
    workflow.children.forEach((child) => {
      const node = child.getNode();
      const state = getObservedState(child);
      console.log(`  ${node.name}: ${node.status} (internal: ${state.taskStatus || 'N/A'})`);
    });
  }

  // Part 5: Error context preservation
  printSection('Part 5: Full Error Context');
  {
    const workflow = new ErrorDemoWorkflow('ContextDemo');

    try {
      await workflow.run();
    } catch (error) {
      const wfError = error as WorkflowError;

      console.log('Complete WorkflowError object:');
      console.log({
        message: wfError.message,
        workflowId: wfError.workflowId,
        hasStack: !!wfError.stack,
        stateFields: Object.keys(wfError.state),
        logCount: wfError.logs.length,
        originalError: wfError.original instanceof Error ? wfError.original.message : 'unknown',
      });

      console.log('\nNote: sensitiveContext is redacted in state snapshot');
      console.log('State:', wfError.state);
    }
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runErrorHandlingExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 6: CONCURRENT TASKS
File: examples/examples/06-concurrent-tasks.ts
================================================================================

/**
 * Example 6: Concurrent Tasks
 *
 * Demonstrates:
 * - Using @Task with concurrent: true option
 * - Manual parallel execution patterns
 * - Comparing sequential vs concurrent execution
 * - Fan-out/fan-in patterns
 */

import {
  Workflow,
  Step,
  Task,
  ObservedState,
  WorkflowTreeDebugger,
} from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

/**
 * Simple worker workflow
 */
class WorkerWorkflow extends Workflow {
  @ObservedState()
  workerId: string;

  @ObservedState()
  processingTime: number;

  @ObservedState()
  result: string = '';

  constructor(id: string, processingTime: number, parent?: Workflow) {
    super(`Worker-${id}`, parent);
    this.workerId = id;
    this.processingTime = processingTime;
  }

  @Step({ trackTiming: true, snapshotState: true })
  async process(): Promise<string> {
    this.logger.info(`Worker ${this.workerId} starting (${this.processingTime}ms)`);
    await sleep(this.processingTime);
    this.result = `Result from ${this.workerId}`;
    this.logger.info(`Worker ${this.workerId} completed`);
    return this.result;
  }

  async run(): Promise<string> {
    this.setStatus('running');
    const result = await this.process();
    this.setStatus('completed');
    return result;
  }
}

/**
 * Sequential execution pattern
 */
class SequentialWorkflow extends Workflow {
  @ObservedState()
  workerCount: number;

  @ObservedState()
  completedWorkers: number = 0;

  private workers: { id: string; time: number }[];

  constructor(name: string, workers: { id: string; time: number }[]) {
    super(name);
    this.workers = workers;
    this.workerCount = workers.length;
  }

  @Task()
  async createWorker(config: { id: string; time: number }): Promise<WorkerWorkflow> {
    return new WorkerWorkflow(config.id, config.time, this);
  }

  async run(): Promise<string[]> {
    this.setStatus('running');
    this.logger.info(`Starting ${this.workerCount} workers SEQUENTIALLY`);

    const results: string[] = [];
    const startTime = Date.now();

    for (const config of this.workers) {
      const worker = await this.createWorker(config);
      const result = await worker.run();
      results.push(result);
      this.completedWorkers++;
    }

    const totalTime = Date.now() - startTime;
    this.logger.info(`All workers completed in ${totalTime}ms`);

    this.setStatus('completed');
    return results;
  }
}

/**
 * Concurrent execution using @Task concurrent option
 */
class ConcurrentTaskWorkflow extends Workflow {
  @ObservedState()
  workerCount: number;

  private workers: { id: string; time: number }[];

  constructor(name: string, workers: { id: string; time: number }[]) {
    super(name);
    this.workers = workers;
    this.workerCount = workers.length;
  }

  // Note: The concurrent option auto-runs the returned workflows
  @Task({ concurrent: true })
  async createAllWorkers(): Promise<WorkerWorkflow[]> {
    return this.workers.map(
      (config) => new WorkerWorkflow(config.id, config.time, this)
    );
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info(`Starting ${this.workerCount} workers with @Task concurrent`);

    const startTime = Date.now();

    // This will create all workers and run them concurrently
    await this.createAllWorkers();

    const totalTime = Date.now() - startTime;
    this.logger.info(`All workers completed in ${totalTime}ms`);

    this.setStatus('completed');
  }
}

/**
 * Manual parallel execution pattern (more control)
 */
class ManualParallelWorkflow extends Workflow {
  @ObservedState()
  workerCount: number;

  private workers: { id: string; time: number }[];

  constructor(name: string, workers: { id: string; time: number }[]) {
    super(name);
    this.workers = workers;
    this.workerCount = workers.length;
  }

  @Task()
  async createWorker(config: { id: string; time: number }): Promise<WorkerWorkflow> {
    return new WorkerWorkflow(config.id, config.time, this);
  }

  async run(): Promise<string[]> {
    this.setStatus('running');
    this.logger.info(`Starting ${this.workerCount} workers MANUALLY PARALLEL`);

    const startTime = Date.now();

    // Create all workers first
    const workerPromises: Promise<WorkerWorkflow>[] = [];
    for (const config of this.workers) {
      workerPromises.push(this.createWorker(config));
    }
    const workers = await Promise.all(workerPromises);

    // Run all workers in parallel
    const results = await Promise.all(workers.map((w) => w.run()));

    const totalTime = Date.now() - startTime;
    this.logger.info(`All workers completed in ${totalTime}ms`);

    this.setStatus('completed');
    return results;
  }
}

/**
 * Fan-out / Fan-in pattern
 */
class FanOutFanInWorkflow extends Workflow {
  @ObservedState()
  inputData: string[] = [];

  @ObservedState()
  processedData: string[] = [];

  @Step({ logStart: true })
  async prepareData(): Promise<void> {
    this.logger.info('Preparing input data');
    this.inputData = ['A', 'B', 'C', 'D', 'E'];
    await sleep(50);
  }

  @Task()
  async createProcessor(item: string): Promise<WorkerWorkflow> {
    // Variable processing times
    const time = 50 + Math.floor(Math.random() * 100);
    return new WorkerWorkflow(item, time, this);
  }

  @Step({ snapshotState: true })
  async fanOut(): Promise<string[]> {
    this.logger.info(`Fan-out: Creating ${this.inputData.length} parallel processors`);

    // Create all workers
    const workers: WorkerWorkflow[] = [];
    for (const item of this.inputData) {
      workers.push(await this.createProcessor(item));
    }

    // Run all in parallel
    const results = await Promise.all(workers.map((w) => w.run()));

    return results;
  }

  @Step({ logFinish: true, snapshotState: true })
  async fanIn(results: string[]): Promise<void> {
    this.logger.info(`Fan-in: Aggregating ${results.length} results`);
    this.processedData = results;
    await sleep(50);
  }

  async run(): Promise<string[]> {
    this.setStatus('running');

    await this.prepareData();
    const results = await this.fanOut();
    await this.fanIn(results);

    this.setStatus('completed');
    return this.processedData;
  }
}

/**
 * Run the concurrent tasks example
 */
export async function runConcurrentTasksExample(): Promise<void> {
  printHeader('Example 6: Concurrent Tasks');

  const workerConfigs = [
    { id: 'W1', time: 200 },
    { id: 'W2', time: 150 },
    { id: 'W3', time: 100 },
    { id: 'W4', time: 180 },
  ];

  // Part 1: Sequential execution
  printSection('Part 1: Sequential Execution');
  {
    const workflow = new SequentialWorkflow('Sequential', workerConfigs);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log('Expected time: ~630ms (200+150+100+180)');
    const start = Date.now();
    await workflow.run();
    const elapsed = Date.now() - start;
    console.log(`Actual time: ${elapsed}ms`);

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 2: Manual parallel execution
  printSection('Part 2: Manual Parallel Execution');
  {
    const workflow = new ManualParallelWorkflow('ManualParallel', workerConfigs);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log('Expected time: ~200ms (max of all workers)');
    const start = Date.now();
    await workflow.run();
    const elapsed = Date.now() - start;
    console.log(`Actual time: ${elapsed}ms`);

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 3: @Task concurrent option
  printSection('Part 3: @Task concurrent: true');
  {
    const workflow = new ConcurrentTaskWorkflow('TaskConcurrent', workerConfigs);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log('Expected time: ~200ms (using concurrent option)');
    const start = Date.now();
    await workflow.run();
    const elapsed = Date.now() - start;
    console.log(`Actual time: ${elapsed}ms`);

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 4: Fan-out / Fan-in
  printSection('Part 4: Fan-Out / Fan-In Pattern');
  {
    const workflow = new FanOutFanInWorkflow('FanOutFanIn');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    const results = await workflow.run();

    console.log('Results:', results);
    console.log('\nTree:');
    console.log(debugger_.toTreeString());

    const stats = debugger_.getStats();
    console.log('Statistics:', stats);
  }

  // Part 5: Performance comparison summary
  printSection('Part 5: Performance Summary');
  {
    const configs = [
      { id: 'A', time: 100 },
      { id: 'B', time: 100 },
      { id: 'C', time: 100 },
      { id: 'D', time: 100 },
    ];

    // Sequential
    const seq = new SequentialWorkflow('SeqTest', configs);
    const seqStart = Date.now();
    await seq.run();
    const seqTime = Date.now() - seqStart;

    // Parallel
    const par = new ManualParallelWorkflow('ParTest', configs);
    const parStart = Date.now();
    await par.run();
    const parTime = Date.now() - parStart;

    console.log('4 workers x 100ms each:');
    console.log(`  Sequential: ${seqTime}ms`);
    console.log(`  Parallel:   ${parTime}ms`);
    console.log(`  Speedup:    ${(seqTime / parTime).toFixed(2)}x`);
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runConcurrentTasksExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 7: AGENT LOOPS
File: examples/examples/07-agent-loops.ts
================================================================================

/**
 * Example 7: Agent Loops with Observability
 *
 * Demonstrates:
 * - Using Agent.prompt() within ctx.step() loops
 * - Multiple agents for different item types
 * - Full event tree visualization with timing
 * - State snapshots at each iteration
 * - Cache hit/miss tracking
 */

import { z } from 'zod';
import {
  Workflow,
  Step,
  ObservedState,
  WorkflowTreeDebugger,
  createAgent,
  createPrompt,
  defaultCache,
} from 'groundswell';
import { printHeader, printSection, sleep, simulateApiCall } from '../utils/helpers.js';

// ============================================================================
// Response Schemas
// ============================================================================

const ClassificationSchema = z.object({
  item: z.string(),
  category: z.enum(['fruit', 'vegetable', 'grain', 'protein', 'dairy']),
  confidence: z.number().min(0).max(1),
  reasoning: z.string(),
});

const TextAnalysisSchema = z.object({
  input: z.string(),
  wordCount: z.number(),
  sentiment: z.enum(['positive', 'negative', 'neutral']),
  keyWords: z.array(z.string()),
});

const NumberAnalysisSchema = z.object({
  input: z.number(),
  isEven: z.boolean(),
  isPrime: z.boolean(),
  factors: z.array(z.number()),
});

type Classification = z.infer<typeof ClassificationSchema>;
type TextAnalysis = z.infer<typeof TextAnalysisSchema>;
type NumberAnalysis = z.infer<typeof NumberAnalysisSchema>;

// ============================================================================
// Simulated Agent Responses (no actual API calls)
// ============================================================================

/**
 * Simulate classification response
 */
async function simulateClassification(item: string): Promise<Classification> {
  const categories: Record<string, 'fruit' | 'vegetable' | 'grain' | 'protein' | 'dairy'> = {
    apple: 'fruit',
    banana: 'fruit',
    cherry: 'fruit',
    carrot: 'vegetable',
    broccoli: 'vegetable',
    rice: 'grain',
    chicken: 'protein',
    milk: 'dairy',
  };

  await sleep(50 + Math.random() * 100);

  return {
    item,
    category: categories[item.toLowerCase()] ?? 'fruit',
    confidence: 0.85 + Math.random() * 0.15,
    reasoning: `${item} is classified based on its nutritional properties`,
  };
}

/**
 * Simulate text analysis response
 */
async function simulateTextAnalysis(input: string): Promise<TextAnalysis> {
  await sleep(30 + Math.random() * 70);

  const words = input.split(/\s+/).filter((w) => w.length > 0);
  const sentiments: Array<'positive' | 'negative' | 'neutral'> = [
    'positive',
    'neutral',
    'negative',
  ];

  return {
    input,
    wordCount: words.length,
    sentiment: sentiments[Math.floor(Math.random() * 3)],
    keyWords: words.filter((w) => w.length > 4).slice(0, 3),
  };
}

/**
 * Simulate number analysis response
 */
async function simulateNumberAnalysis(input: number): Promise<NumberAnalysis> {
  await sleep(20 + Math.random() * 50);

  const isPrime = (n: number): boolean => {
    if (n < 2) return false;
    for (let i = 2; i <= Math.sqrt(n); i++) {
      if (n % i === 0) return false;
    }
    return true;
  };

  const getFactors = (n: number): number[] => {
    const factors: number[] = [];
    for (let i = 1; i <= n; i++) {
      if (n % i === 0) factors.push(i);
    }
    return factors;
  };

  return {
    input,
    isEven: input % 2 === 0,
    isPrime: isPrime(input),
    factors: getFactors(input),
  };
}

// ============================================================================
// Workflow Definitions
// ============================================================================

/**
 * Basic agent loop workflow - processes items sequentially
 */
class BasicAgentLoopWorkflow extends Workflow {
  @ObservedState()
  items: string[] = [];

  @ObservedState()
  results: Classification[] = [];

  @ObservedState()
  currentIndex: number = 0;

  constructor(name: string, items: string[]) {
    super(name);
    this.items = items;
  }

  @Step({ trackTiming: true, snapshotState: true })
  async processItem(item: string): Promise<Classification> {
    this.logger.info(`Processing: ${item}`);
    const result = await simulateClassification(item);
    this.results.push(result);
    this.currentIndex++;
    return result;
  }

  async run(): Promise<Classification[]> {
    this.setStatus('running');
    this.logger.info(`Starting loop with ${this.items.length} items`);

    const startTime = Date.now();

    for (const item of this.items) {
      await this.processItem(item);
    }

    const duration = Date.now() - startTime;
    this.logger.info(`Loop completed in ${duration}ms`);

    this.setStatus('completed');
    return this.results;
  }
}

/**
 * Multi-agent loop workflow - uses different agents for different data types
 */
class MultiAgentLoopWorkflow extends Workflow {
  @ObservedState()
  mixedData: Array<string | number> = [];

  @ObservedState()
  textResults: TextAnalysis[] = [];

  @ObservedState()
  numberResults: NumberAnalysis[] = [];

  @ObservedState()
  processedCount: number = 0;

  constructor(name: string, data: Array<string | number>) {
    super(name);
    this.mixedData = data;
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'analyze-text' })
  async analyzeText(input: string): Promise<TextAnalysis> {
    this.logger.info(`TextAgent analyzing: "${input}"`);
    const result = await simulateTextAnalysis(input);
    this.textResults.push(result);
    this.processedCount++;
    return result;
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'analyze-number' })
  async analyzeNumber(input: number): Promise<NumberAnalysis> {
    this.logger.info(`NumberAgent analyzing: ${input}`);
    const result = await simulateNumberAnalysis(input);
    this.numberResults.push(result);
    this.processedCount++;
    return result;
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info(`Starting multi-agent loop with ${this.mixedData.length} items`);

    const startTime = Date.now();

    for (const input of this.mixedData) {
      if (typeof input === 'string') {
        await this.analyzeText(input);
      } else {
        await this.analyzeNumber(input);
      }
    }

    const duration = Date.now() - startTime;
    this.logger.info(`Multi-agent loop completed in ${duration}ms`);
    this.logger.info(`Text results: ${this.textResults.length}, Number results: ${this.numberResults.length}`);

    this.setStatus('completed');
  }
}

/**
 * Cached agent loop workflow - demonstrates cache hits across iterations
 */
class CachedAgentLoopWorkflow extends Workflow {
  @ObservedState()
  items: string[] = [];

  @ObservedState()
  cacheHits: number = 0;

  @ObservedState()
  cacheMisses: number = 0;

  private cache: Map<string, Classification> = new Map();

  constructor(name: string, items: string[]) {
    super(name);
    this.items = items;
  }

  @Step({ trackTiming: true, snapshotState: true })
  async processWithCache(item: string): Promise<Classification> {
    // Check local cache first
    const cached = this.cache.get(item);
    if (cached) {
      this.cacheHits++;
      this.logger.info(`Cache HIT for: ${item}`);
      return cached;
    }

    this.cacheMisses++;
    this.logger.info(`Cache MISS for: ${item}`);

    const result = await simulateClassification(item);
    this.cache.set(item, result);
    return result;
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info(`Starting cached loop with ${this.items.length} items`);

    const startTime = Date.now();

    for (const item of this.items) {
      await this.processWithCache(item);
    }

    const duration = Date.now() - startTime;
    this.logger.info(`Cached loop completed in ${duration}ms`);
    this.logger.info(`Cache hits: ${this.cacheHits}, misses: ${this.cacheMisses}`);

    this.setStatus('completed');
  }
}

// ============================================================================
// Main Example Runner
// ============================================================================

/**
 * Run the Agent Loops example
 */
export async function runAgentLoopsExample(): Promise<void> {
  printHeader('Example 7: Agent Loops with Observability');

  // Part 1: Basic Agent Loop
  printSection('Part 1: Basic Agent Loop');
  {
    const items = ['apple', 'banana', 'cherry', 'carrot', 'broccoli'];
    const workflow = new BasicAgentLoopWorkflow('ClassificationLoop', items);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log(`Processing ${items.length} items: ${items.join(', ')}\n`);

    const startTime = Date.now();
    const results = await workflow.run();
    const elapsed = Date.now() - startTime;

    console.log(`\nResults (${elapsed}ms total):`);
    for (const result of results) {
      console.log(`  ${result.item}: ${result.category} (${(result.confidence * 100).toFixed(1)}%)`);
    }

    console.log('\nTree visualization:');
    console.log(debugger_.toTreeString());

    const stats = debugger_.getStats();
    console.log('Statistics:', {
      totalNodes: stats.totalNodes,
      completedSteps: stats.completed,
    });
  }

  // Part 2: Multi-Agent Loop
  printSection('Part 2: Multi-Agent Loop (Different Agents per Type)');
  {
    const mixedData: Array<string | number> = [
      'Hello world',
      42,
      'TypeScript is great',
      17,
      'Agent loops',
      100,
    ];

    const workflow = new MultiAgentLoopWorkflow('MultiAgentLoop', mixedData);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log(`Processing mixed data: ${mixedData.length} items\n`);

    const startTime = Date.now();
    await workflow.run();
    const elapsed = Date.now() - startTime;

    console.log(`\nText Analysis Results:`);
    for (const result of workflow.textResults) {
      console.log(`  "${result.input}": ${result.wordCount} words, ${result.sentiment} sentiment`);
    }

    console.log(`\nNumber Analysis Results:`);
    for (const result of workflow.numberResults) {
      console.log(`  ${result.input}: even=${result.isEven}, prime=${result.isPrime}, factors=[${result.factors.join(',')}]`);
    }

    console.log(`\nTotal time: ${elapsed}ms`);
    console.log('\nTree visualization:');
    console.log(debugger_.toTreeString());
  }

  // Part 3: Cached Agent Loop
  printSection('Part 3: Cached Agent Loop (Duplicate Detection)');
  {
    // Include duplicates to demonstrate cache hits
    const items = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];

    const workflow = new CachedAgentLoopWorkflow('CachedLoop', items);
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log(`Processing ${items.length} items with duplicates: ${items.join(', ')}\n`);

    const startTime = Date.now();
    await workflow.run();
    const elapsed = Date.now() - startTime;

    console.log(`\nCache Performance:`);
    console.log(`  Total items: ${items.length}`);
    console.log(`  Cache hits:  ${workflow.cacheHits}`);
    console.log(`  Cache misses: ${workflow.cacheMisses}`);
    console.log(`  Hit rate: ${((workflow.cacheHits / items.length) * 100).toFixed(1)}%`);
    console.log(`\nTotal time: ${elapsed}ms`);

    console.log('\nTree visualization:');
    console.log(debugger_.toTreeString());

    const stats = debugger_.getStats();
    console.log('Statistics:', stats);
  }

  // Part 4: Performance Comparison
  printSection('Part 4: Sequential vs Timing Analysis');
  {
    const items = ['item1', 'item2', 'item3', 'item4', 'item5'];

    console.log('Sequential processing of 5 items:');
    const seqWorkflow = new BasicAgentLoopWorkflow('SequentialLoop', items);

    const seqStart = Date.now();
    await seqWorkflow.run();
    const seqTime = Date.now() - seqStart;

    console.log(`  Sequential time: ${seqTime}ms`);
    console.log(`  Average per item: ${(seqTime / items.length).toFixed(1)}ms`);

    // Show the timing from tree stats
    const debugger_ = new WorkflowTreeDebugger(seqWorkflow);
    const logs = debugger_.getTree().logs;
    console.log(`\nLog entries: ${logs.length}`);
    for (const log of logs.slice(-5)) {
      console.log(`  [${log.level}] ${log.message}`);
    }
  }

  console.log('\n=== Example 7 Complete ===');
}

// Allow direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  runAgentLoopsExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 8: SDK FEATURES
File: examples/examples/08-sdk-features.ts
================================================================================

/**
 * Example 8: SDK Features Integration
 *
 * Demonstrates:
 * - Custom tool definitions with handlers
 * - MCP server configuration (inprocess)
 * - Pre/Post tool hooks for logging and validation
 * - Skills integration with system prompt content
 * - Environment variable pass-through
 */

import { z } from 'zod';
import {
  Workflow,
  Step,
  ObservedState,
  WorkflowTreeDebugger,
  MCPHandler,
} from 'groundswell';
import type {
  Tool,
  AgentHooks,
  PreToolUseContext,
  PostToolUseContext,
  SessionStartContext,
  SessionEndContext,
} from 'groundswell';
import { printHeader, printSection, sleep } from '../utils/helpers.js';

// ============================================================================
// Custom Tool Definitions
// ============================================================================

/**
 * Calculator tool - performs basic arithmetic
 */
const calculatorTool: Tool = {
  name: 'calculate',
  description: 'Performs basic arithmetic operations (add, subtract, multiply, divide)',
  input_schema: {
    type: 'object' as const,
    properties: {
      operation: {
        type: 'string',
        enum: ['add', 'subtract', 'multiply', 'divide'],
        description: 'The arithmetic operation to perform',
      },
      a: {
        type: 'number',
        description: 'The first operand',
      },
      b: {
        type: 'number',
        description: 'The second operand',
      },
    },
    required: ['operation', 'a', 'b'],
  },
};

/**
 * Weather tool - simulates weather lookup
 */
const weatherTool: Tool = {
  name: 'get_weather',
  description: 'Gets current weather for a location',
  input_schema: {
    type: 'object' as const,
    properties: {
      location: {
        type: 'string',
        description: 'City name or location',
      },
      units: {
        type: 'string',
        enum: ['celsius', 'fahrenheit'],
        description: 'Temperature units',
      },
    },
    required: ['location'],
  },
};

/**
 * Database tool - simulates database queries
 */
const databaseTool: Tool = {
  name: 'query_database',
  description: 'Executes a database query and returns results',
  input_schema: {
    type: 'object' as const,
    properties: {
      table: {
        type: 'string',
        description: 'Table name to query',
      },
      filter: {
        type: 'object',
        description: 'Filter conditions',
      },
      limit: {
        type: 'number',
        description: 'Maximum results to return',
      },
    },
    required: ['table'],
  },
};

// ============================================================================
// Tool Handlers
// ============================================================================

interface CalculateInput {
  operation: 'add' | 'subtract' | 'multiply' | 'divide';
  a: number;
  b: number;
}

interface WeatherInput {
  location: string;
  units?: 'celsius' | 'fahrenheit';
}

interface DatabaseInput {
  table: string;
  filter?: Record<string, unknown>;
  limit?: number;
}

/**
 * Handle calculator operations
 */
async function handleCalculate(input: CalculateInput): Promise<{ result: number; expression: string }> {
  await sleep(50); // Simulate processing time

  let result: number;
  let expression: string;

  switch (input.operation) {
    case 'add':
      result = input.a + input.b;
      expression = `${input.a} + ${input.b} = ${result}`;
      break;
    case 'subtract':
      result = input.a - input.b;
      expression = `${input.a} - ${input.b} = ${result}`;
      break;
    case 'multiply':
      result = input.a * input.b;
      expression = `${input.a} × ${input.b} = ${result}`;
      break;
    case 'divide':
      if (input.b === 0) throw new Error('Division by zero');
      result = input.a / input.b;
      expression = `${input.a} ÷ ${input.b} = ${result}`;
      break;
  }

  return { result, expression };
}

/**
 * Handle weather lookup (simulated)
 */
async function handleWeather(input: WeatherInput): Promise<{
  location: string;
  temperature: number;
  units: string;
  conditions: string;
}> {
  await sleep(100); // Simulate API call

  const weatherData: Record<string, { temp: number; conditions: string }> = {
    'new york': { temp: 72, conditions: 'Partly cloudy' },
    london: { temp: 58, conditions: 'Rainy' },
    tokyo: { temp: 85, conditions: 'Sunny' },
    sydney: { temp: 68, conditions: 'Clear' },
  };

  const locationKey = input.location.toLowerCase();
  const data = weatherData[locationKey] ?? { temp: 70, conditions: 'Unknown' };

  const temp =
    input.units === 'celsius' ? Math.round((data.temp - 32) * (5 / 9)) : data.temp;

  return {
    location: input.location,
    temperature: temp,
    units: input.units ?? 'fahrenheit',
    conditions: data.conditions,
  };
}

/**
 * Handle database queries (simulated)
 */
async function handleDatabase(input: DatabaseInput): Promise<{
  table: string;
  rowCount: number;
  results: Array<Record<string, unknown>>;
}> {
  await sleep(75); // Simulate query time

  const mockData: Record<string, Array<Record<string, unknown>>> = {
    users: [
      { id: 1, name: 'Alice', role: 'admin' },
      { id: 2, name: 'Bob', role: 'user' },
      { id: 3, name: 'Charlie', role: 'user' },
    ],
    products: [
      { id: 1, name: 'Widget', price: 9.99 },
      { id: 2, name: 'Gadget', price: 19.99 },
    ],
    orders: [
      { id: 1, userId: 1, total: 29.98 },
      { id: 2, userId: 2, total: 9.99 },
    ],
  };

  const tableData = mockData[input.table] ?? [];
  const limit = input.limit ?? tableData.length;
  const results = tableData.slice(0, limit);

  return {
    table: input.table,
    rowCount: results.length,
    results,
  };
}

// ============================================================================
// Lifecycle Hooks
// ============================================================================

/**
 * Create comprehensive agent hooks for logging and validation
 */
function createLoggingHooks(): AgentHooks {
  const hookLogs: string[] = [];

  return {
    preToolUse: [
      async (ctx: PreToolUseContext): Promise<void> => {
        const log = `[PRE] Tool: ${ctx.toolName}, Input: ${JSON.stringify(ctx.toolInput)}`;
        hookLogs.push(log);
        console.log(`  ${log}`);
      },
      async (ctx: PreToolUseContext): Promise<void> => {
        // Validation hook - could block execution if needed
        if (ctx.toolName === 'calculate') {
          const input = ctx.toolInput as CalculateInput;
          if (input.operation === 'divide' && input.b === 0) {
            console.log('  [PRE] WARNING: Division by zero detected');
          }
        }
      },
    ],
    postToolUse: [
      async (ctx: PostToolUseContext): Promise<void> => {
        const log = `[POST] Tool: ${ctx.toolName}, Duration: ${ctx.duration}ms`;
        hookLogs.push(log);
        console.log(`  ${log}`);
      },
      async (ctx: PostToolUseContext): Promise<void> => {
        // Metrics collection hook
        const output = ctx.toolOutput as Record<string, unknown>;
        if (output.result !== undefined) {
          console.log(`  [POST] Result: ${output.result}`);
        }
      },
    ],
    sessionStart: [
      async (ctx: SessionStartContext): Promise<void> => {
        console.log(`  [SESSION] Started: Agent ${ctx.agentName} (${ctx.agentId})`);
        hookLogs.push(`Session started: ${ctx.agentName}`);
      },
    ],
    sessionEnd: [
      async (ctx: SessionEndContext): Promise<void> => {
        console.log(`  [SESSION] Ended: Agent ${ctx.agentName}, Duration: ${ctx.totalDuration}ms`);
        hookLogs.push(`Session ended: ${ctx.agentName} (${ctx.totalDuration}ms)`);
      },
    ],
  };
}

// ============================================================================
// Workflow Definitions
// ============================================================================

/**
 * Tool demonstration workflow
 */
class ToolDemoWorkflow extends Workflow {
  @ObservedState()
  toolCalls: Array<{ tool: string; input: unknown; result: unknown }> = [];

  private mcpHandler: MCPHandler;

  constructor(name: string) {
    super(name);
    this.mcpHandler = new MCPHandler();

    // Register MCP server with tools (inprocess transport)
    this.mcpHandler.registerServer({
      name: 'demo',
      transport: 'inprocess',
      tools: [calculatorTool, weatherTool, databaseTool],
    });

    // Register tool executors
    this.mcpHandler.registerToolExecutor('demo', 'calculate', (input) =>
      handleCalculate(input as CalculateInput)
    );
    this.mcpHandler.registerToolExecutor('demo', 'get_weather', (input) =>
      handleWeather(input as WeatherInput)
    );
    this.mcpHandler.registerToolExecutor('demo', 'query_database', (input) =>
      handleDatabase(input as DatabaseInput)
    );
  }

  @Step({ trackTiming: true })
  async callTool(toolName: string, input: unknown): Promise<unknown> {
    this.logger.info(`Calling tool: ${toolName}`);

    // Use full tool name: serverName__toolName
    const fullName = `demo__${toolName}`;
    const result = await this.mcpHandler.executeTool(fullName, input);

    this.toolCalls.push({ tool: toolName, input, result: result.content });
    return result.content;
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting tool demonstration');

    // Demonstrate calculator tool
    await this.callTool('calculate', { operation: 'add', a: 10, b: 5 });
    await this.callTool('calculate', { operation: 'multiply', a: 7, b: 8 });

    // Demonstrate weather tool
    await this.callTool('get_weather', { location: 'Tokyo', units: 'celsius' });
    await this.callTool('get_weather', { location: 'London' });

    // Demonstrate database tool
    await this.callTool('query_database', { table: 'users', limit: 2 });
    await this.callTool('query_database', { table: 'products' });

    this.logger.info(`Total tool calls: ${this.toolCalls.length}`);
    this.setStatus('completed');
  }
}

/**
 * Hook demonstration workflow
 */
class HookDemoWorkflow extends Workflow {
  @ObservedState()
  hookEvents: string[] = [];

  private mcpHandler: MCPHandler;

  constructor(name: string) {
    super(name);
    this.mcpHandler = new MCPHandler();

    // Register MCP server with calculator tool
    this.mcpHandler.registerServer({
      name: 'calc',
      transport: 'inprocess',
      tools: [calculatorTool],
    });
    this.mcpHandler.registerToolExecutor('calc', 'calculate', (input) =>
      handleCalculate(input as CalculateInput)
    );
  }

  @Step({ trackTiming: true, logStart: true, logFinish: true })
  async executeWithHooks(): Promise<void> {
    // Simulate hook execution flow
    this.hookEvents.push('preToolUse: calculate');
    const result = await handleCalculate({ operation: 'add', a: 100, b: 200 });
    this.hookEvents.push(`postToolUse: calculate (result=${result.result})`);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Demonstrating lifecycle hooks');

    this.hookEvents.push('sessionStart');
    await this.executeWithHooks();
    this.hookEvents.push('sessionEnd');

    this.logger.info(`Hook events: ${this.hookEvents.length}`);
    this.setStatus('completed');
  }
}

/**
 * Skills demonstration workflow
 */
class SkillsDemoWorkflow extends Workflow {
  @ObservedState()
  skillContent: string = '';

  @ObservedState()
  systemPrompt: string = '';

  constructor(name: string) {
    super(name);
  }

  @Step({ snapshotState: true })
  async loadSkill(): Promise<void> {
    // Simulate loading skill content from SKILL.md
    this.skillContent = `
# Math Expert Skill

You are an expert mathematician. You can:
- Perform complex calculations
- Explain mathematical concepts
- Solve equations step by step

## Usage
Ask me any math question and I'll provide a detailed solution.
    `.trim();

    this.logger.info('Loaded skill: Math Expert');
  }

  @Step({ snapshotState: true })
  async buildSystemPrompt(): Promise<void> {
    const baseSystem = 'You are a helpful assistant.';

    // Skills inject content into system prompt
    this.systemPrompt = `${baseSystem}

## Available Skills

${this.skillContent}

## Instructions
Use the loaded skills to assist the user with their requests.`;

    this.logger.info('Built system prompt with skill content');
  }

  async run(): Promise<string> {
    this.setStatus('running');
    this.logger.info('Demonstrating skills integration');

    await this.loadSkill();
    await this.buildSystemPrompt();

    this.logger.info(`System prompt length: ${this.systemPrompt.length} chars`);
    this.setStatus('completed');

    return this.systemPrompt;
  }
}

/**
 * Environment variables demonstration workflow
 */
class EnvVarsDemoWorkflow extends Workflow {
  @ObservedState()
  capturedEnvVars: Record<string, string> = {};

  @ObservedState({ redact: true })
  sensitiveVars: Record<string, string> = {};

  constructor(name: string) {
    super(name);
  }

  @Step({ snapshotState: true })
  async captureEnvironment(): Promise<void> {
    // Capture non-sensitive environment info
    this.capturedEnvVars = {
      NODE_ENV: process.env.NODE_ENV ?? 'development',
      PWD: process.env.PWD ?? '(unknown)',
      SHELL: process.env.SHELL ?? '(unknown)',
    };

    // Simulate sensitive vars (would be passed to agent)
    this.sensitiveVars = {
      API_KEY: 'demo-key-12345',
      DATABASE_URL: 'postgres://localhost:5432/demo',
    };

    this.logger.info('Captured environment variables');
  }

  @Step()
  async demonstratePassThrough(): Promise<void> {
    // In real usage, env vars are passed through to agent execution
    this.logger.info('Environment vars would be set during agent execution');
    this.logger.info(`Non-sensitive vars: ${Object.keys(this.capturedEnvVars).join(', ')}`);
    this.logger.info(`Sensitive vars (redacted): ${Object.keys(this.sensitiveVars).length} vars`);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Demonstrating environment variable handling');

    await this.captureEnvironment();
    await this.demonstratePassThrough();

    this.setStatus('completed');
  }
}

// ============================================================================
// Main Example Runner
// ============================================================================

/**
 * Run the SDK Features example
 */
export async function runSDKFeaturesExample(): Promise<void> {
  printHeader('Example 8: SDK Features Integration');

  // Part 1: Custom Tool Definitions
  printSection('Part 1: Custom Tool Definitions & Handlers');
  {
    const workflow = new ToolDemoWorkflow('ToolDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    console.log('Registered tools:');
    console.log('  - calculate: Basic arithmetic operations');
    console.log('  - get_weather: Weather lookup (simulated)');
    console.log('  - query_database: Database queries (simulated)\n');

    await workflow.run();

    console.log('\nTool call results:');
    for (const call of workflow.toolCalls) {
      console.log(`  ${call.tool}: ${JSON.stringify(call.result)}`);
    }

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 2: MCP Server Integration
  printSection('Part 2: MCP Handler / In-Process Server');
  {
    console.log('MCP Handler features:');
    console.log('  - Register servers with tools (registerServer)');
    console.log('  - Register executors for inprocess tools (registerToolExecutor)');
    console.log('  - Execute tools by full name: serverName__toolName');
    console.log('  - Return structured ToolResult objects');
    console.log('  - Error handling with is_error flag\n');

    const mcpHandler = new MCPHandler();

    // Register server with tool
    const demoTool: Tool = {
      name: 'demo_tool',
      description: 'A demonstration tool',
      input_schema: {
        type: 'object' as const,
        properties: { test: { type: 'string' } },
        required: [],
      },
    };

    mcpHandler.registerServer({
      name: 'demo',
      transport: 'inprocess',
      tools: [demoTool],
    });

    mcpHandler.registerToolExecutor('demo', 'demo_tool', async (input: unknown) => ({
      status: 'success',
      input,
    }));

    const tools = mcpHandler.getTools();
    console.log(`Registered tools count: ${tools.length}`);

    // Execute using full name: serverName__toolName
    const result = await mcpHandler.executeTool('demo__demo_tool', { test: 'data' });
    console.log(`Execution result: ${JSON.stringify(result)}`);
  }

  // Part 3: Lifecycle Hooks
  printSection('Part 3: Lifecycle Hooks (Pre/Post Tool, Session)');
  {
    console.log('Hook types demonstrated:');
    console.log('  - preToolUse: Log input, validate parameters');
    console.log('  - postToolUse: Log duration, collect metrics');
    console.log('  - sessionStart: Initialize session context');
    console.log('  - sessionEnd: Cleanup, final metrics\n');

    const workflow = new HookDemoWorkflow('HookDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    await workflow.run();

    console.log('\nHook events captured:');
    for (const event of workflow.hookEvents) {
      console.log(`  → ${event}`);
    }

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 4: Skills Integration
  printSection('Part 4: Skills Integration');
  {
    console.log('Skills system:');
    console.log('  - Load SKILL.md content from skill directories');
    console.log('  - Inject skill content into system prompt');
    console.log('  - Multiple skills can be combined\n');

    const workflow = new SkillsDemoWorkflow('SkillsDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    const systemPrompt = await workflow.run();

    console.log('Generated system prompt preview:');
    console.log('─'.repeat(50));
    console.log(systemPrompt.slice(0, 300) + '...');
    console.log('─'.repeat(50));

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 5: Environment Variables
  printSection('Part 5: Environment Variable Pass-Through');
  {
    console.log('Environment handling:');
    console.log('  - Pass env vars to agent execution context');
    console.log('  - Sensitive vars marked with @ObservedState({ redact: true })');
    console.log('  - Vars restored after execution\n');

    const workflow = new EnvVarsDemoWorkflow('EnvVarsDemo');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    await workflow.run();

    console.log('\nCaptured environment:');
    for (const [key, value] of Object.entries(workflow.capturedEnvVars)) {
      console.log(`  ${key}: ${value}`);
    }

    // Get state snapshot to show redaction
    const logs = debugger_.getAllLogs();
    console.log(`\nLog entries: ${logs.length}`);

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  console.log('\n=== Example 8 Complete ===');
}

// Allow direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  runSDKFeaturesExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 9: REFLECTION
File: examples/examples/09-reflection.ts
================================================================================

/**
 * Example 9: Multi-level Reflection
 *
 * Demonstrates:
 * - Prompt-level reflection (enableReflection on prompt)
 * - Agent-level reflection (agent.reflect() method)
 * - Workflow-level reflection (step failure retry)
 * - Reflection events in tree output
 * - Error recovery with revised prompts
 */

import { z } from 'zod';
import {
  Workflow,
  Step,
  ObservedState,
  WorkflowTreeDebugger,
  ReflectionManager,
  executeWithReflection,
  DEFAULT_REFLECTION_CONFIG,
  createReflectionConfig,
} from 'groundswell';
import type {
  ReflectionConfig,
  ReflectionEntry,
  ReflectionContext,
  WorkflowNode,
} from 'groundswell';
import { printHeader, printSection, sleep, simulateUnreliableTask } from '../utils/helpers.js';

// ============================================================================
// Response Schemas
// ============================================================================

const StrictAnswerSchema = z.object({
  answer: z.string().min(10, 'Answer must be at least 10 characters'),
  confidence: z.number().min(0.8, 'Confidence must be at least 0.8'),
  reasoning: z.string().min(20, 'Reasoning must be detailed'),
});

const AnalysisSchema = z.object({
  summary: z.string(),
  keyPoints: z.array(z.string()).min(2, 'Must have at least 2 key points'),
  recommendation: z.string(),
});

type StrictAnswer = z.infer<typeof StrictAnswerSchema>;
type Analysis = z.infer<typeof AnalysisSchema>;

// ============================================================================
// Simulated Responses (for demonstration without API calls)
// ============================================================================

/**
 * Simulate a response that might fail schema validation
 */
async function simulateStrictResponse(
  attemptNumber: number
): Promise<StrictAnswer> {
  await sleep(50);

  // First attempt might fail validation
  if (attemptNumber === 1 && Math.random() > 0.3) {
    return {
      answer: 'Short', // Too short - will fail validation
      confidence: 0.5, // Too low - will fail validation
      reasoning: 'Brief', // Too short
    };
  }

  // Subsequent attempts return valid data
  return {
    answer: 'This is a comprehensive answer that meets the minimum length requirement',
    confidence: 0.92,
    reasoning: 'Based on careful analysis of the input data and consideration of multiple factors',
  };
}

/**
 * Simulate an analysis response
 */
async function simulateAnalysis(): Promise<Analysis> {
  await sleep(75);

  return {
    summary: 'The analysis shows positive trends across all metrics',
    keyPoints: [
      'Revenue increased by 15%',
      'Customer satisfaction improved',
      'Operational efficiency gains',
    ],
    recommendation: 'Continue current strategy with minor adjustments',
  };
}

// ============================================================================
// Workflow Definitions
// ============================================================================

/**
 * Prompt-level reflection demonstration
 */
class PromptReflectionWorkflow extends Workflow {
  @ObservedState()
  attemptCount: number = 0;

  @ObservedState()
  validationErrors: string[] = [];

  @ObservedState()
  finalResult: StrictAnswer | null = null;

  private reflectionManager: ReflectionManager;

  constructor(name: string) {
    super(name);
    this.reflectionManager = new ReflectionManager(
      createReflectionConfig({ enabled: true, maxAttempts: 3 })
    );
  }

  @Step({ trackTiming: true, snapshotState: true })
  async executeWithSchemaValidation(): Promise<StrictAnswer> {
    this.logger.info('Attempting prompt with strict schema validation');

    // Simulate multiple attempts until schema validates
    for (let attempt = 1; attempt <= 3; attempt++) {
      this.attemptCount = attempt;
      this.logger.info(`Attempt ${attempt}/3`);

      const response = await simulateStrictResponse(attempt);

      // Validate against schema
      const result = StrictAnswerSchema.safeParse(response);

      if (result.success) {
        this.logger.info('Schema validation passed!');
        this.finalResult = result.data;
        return result.data;
      }

      // Collect validation errors
      const errors = result.error.errors.map((e) => `${e.path.join('.')}: ${e.message}`);
      this.validationErrors.push(...errors);
      this.logger.warn(`Validation failed: ${errors.join(', ')}`);

      if (attempt < 3) {
        this.logger.info('Reflecting on error and retrying...');
        await sleep(100); // Reflection delay
      }
    }

    throw new Error('Max reflection attempts exceeded - schema validation failed');
  }

  async run(): Promise<StrictAnswer | null> {
    this.setStatus('running');
    this.logger.info('Starting prompt-level reflection demo');

    try {
      const result = await this.executeWithSchemaValidation();
      this.setStatus('completed');
      return result;
    } catch (error) {
      this.logger.error(`Failed after ${this.attemptCount} attempts`);
      this.setStatus('failed');
      return null;
    }
  }
}

/**
 * Agent-level reflection demonstration
 */
class AgentReflectionWorkflow extends Workflow {
  @ObservedState()
  reflectionHistory: Array<{
    attempt: number;
    action: string;
    result: string;
  }> = [];

  @ObservedState()
  analysisResult: Analysis | null = null;

  constructor(name: string) {
    super(name);
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'reflect-analysis' })
  async reflectOnAnalysis(): Promise<Analysis> {
    this.logger.info('Agent reflecting on analysis approach');

    // Step 1: Initial reasoning
    this.reflectionHistory.push({
      attempt: 1,
      action: 'Initial reasoning',
      result: 'Considering multiple analysis angles',
    });
    await sleep(50);

    // Step 2: Self-correction
    this.reflectionHistory.push({
      attempt: 2,
      action: 'Self-correction',
      result: 'Identified potential bias in initial approach',
    });
    await sleep(50);

    // Step 3: Revised approach
    this.reflectionHistory.push({
      attempt: 3,
      action: 'Revised analysis',
      result: 'Applied broader perspective for balanced view',
    });
    await sleep(50);

    // Final result after reflection
    const result = await simulateAnalysis();
    this.analysisResult = result;

    return result;
  }

  @Step({ snapshotState: true })
  async summarizeReflection(): Promise<string> {
    const summary = `
Reflection Summary:
  Total steps: ${this.reflectionHistory.length}
  ${this.reflectionHistory.map((r) => `  - ${r.action}: ${r.result}`).join('\n')}
    `.trim();

    this.logger.info('Reflection process complete');
    return summary;
  }

  async run(): Promise<Analysis | null> {
    this.setStatus('running');
    this.logger.info('Starting agent-level reflection demo');

    // System prompt would include reflection instructions:
    // "Before answering, reflect on your reasoning step by step.
    //  Consider alternative approaches and potential errors.
    //  Then provide your final answer."

    const result = await this.reflectOnAnalysis();
    await this.summarizeReflection();

    this.setStatus('completed');
    return result;
  }
}

/**
 * Workflow-level reflection demonstration
 */
class WorkflowReflectionWorkflow extends Workflow {
  @ObservedState()
  stepAttempts: Record<string, number> = {};

  @ObservedState()
  failureReasons: string[] = [];

  @ObservedState()
  successfulSteps: string[] = [];

  private reflectionManager: ReflectionManager;

  constructor(name: string) {
    super(name);
    this.reflectionManager = new ReflectionManager(
      createReflectionConfig({ enabled: true, maxAttempts: 3, retryDelayMs: 100 })
    );

    // Set event emitter for reflection events
    this.reflectionManager.setEventEmitter((event) => {
      if (event.type === 'reflectionStart') {
        this.logger.info(`Reflection started at ${event.level} level`);
      } else if (event.type === 'reflectionEnd') {
        this.logger.info(`Reflection ended: ${event.success ? 'will retry' : 'will abort'}`);
      }
    });
  }

  @Step({ trackTiming: true, snapshotState: true })
  async unreliableStep(): Promise<string> {
    const stepName = 'unreliableStep';
    this.stepAttempts[stepName] = (this.stepAttempts[stepName] ?? 0) + 1;
    const attempt = this.stepAttempts[stepName];

    this.logger.info(`Executing unreliable step (attempt ${attempt})`);

    // Simulate failure on first 2 attempts
    if (attempt < 3) {
      const reason = `Transient failure on attempt ${attempt}`;
      this.failureReasons.push(reason);
      throw new Error(reason);
    }

    this.successfulSteps.push(stepName);
    return `Success on attempt ${attempt}`;
  }

  @Step({ trackTiming: true, snapshotState: true })
  async reliableStep(): Promise<string> {
    const stepName = 'reliableStep';
    this.stepAttempts[stepName] = 1;
    this.logger.info('Executing reliable step');
    await sleep(50);
    this.successfulSteps.push(stepName);
    return 'Reliable step completed';
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting workflow-level reflection demo');

    // Create mock node for reflection context
    const mockNode: WorkflowNode = {
      id: this.id,
      name: this.name,
      status: 'running',
      children: [],
      events: [],
    };

    // Execute unreliable step with reflection wrapper
    try {
      await executeWithReflection(
        () => this.unreliableStep(),
        this.reflectionManager,
        (error, attempt, history) => ({
          level: 'workflow',
          failedNode: mockNode,
          error,
          attemptNumber: attempt,
          previousAttempts: history,
        })
      );
    } catch (error) {
      this.logger.error(`Step failed after max attempts: ${(error as Error).message}`);
    }

    // Execute reliable step
    await this.reliableStep();

    this.logger.info(`Completed steps: ${this.successfulSteps.join(', ')}`);
    this.logger.info(`Total failures: ${this.failureReasons.length}`);

    this.setStatus('completed');
  }
}

/**
 * Combined multi-level reflection demonstration
 */
class MultiLevelReflectionWorkflow extends Workflow {
  @ObservedState()
  reflectionEvents: Array<{
    level: string;
    type: string;
    timestamp: number;
  }> = [];

  private reflectionManager: ReflectionManager;

  constructor(name: string) {
    super(name);
    this.reflectionManager = new ReflectionManager(
      createReflectionConfig({ enabled: true, maxAttempts: 3 })
    );

    this.reflectionManager.setEventEmitter((event) => {
      if (event.type === 'reflectionStart' || event.type === 'reflectionEnd') {
        this.reflectionEvents.push({
          level: (event as { level: string }).level,
          type: event.type,
          timestamp: Date.now(),
        });
      }
    });
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'prompt-level' })
  async promptLevelReflection(): Promise<void> {
    this.logger.info('Prompt-level: Schema validation with retry');
    this.reflectionEvents.push({
      level: 'prompt',
      type: 'validation',
      timestamp: Date.now(),
    });
    await sleep(50);
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'agent-level' })
  async agentLevelReflection(): Promise<void> {
    this.logger.info('Agent-level: Self-correction before final answer');
    this.reflectionEvents.push({
      level: 'agent',
      type: 'self-correction',
      timestamp: Date.now(),
    });
    await sleep(50);
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'workflow-level' })
  async workflowLevelReflection(): Promise<void> {
    this.logger.info('Workflow-level: Step retry on failure');
    this.reflectionEvents.push({
      level: 'workflow',
      type: 'step-retry',
      timestamp: Date.now(),
    });
    await sleep(50);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting multi-level reflection demonstration');

    await this.promptLevelReflection();
    await this.agentLevelReflection();
    await this.workflowLevelReflection();

    this.logger.info(`Total reflection events: ${this.reflectionEvents.length}`);
    this.setStatus('completed');
  }
}

// ============================================================================
// Main Example Runner
// ============================================================================

/**
 * Run the Multi-level Reflection example
 */
export async function runReflectionExample(): Promise<void> {
  printHeader('Example 9: Multi-level Reflection');

  // Part 1: Prompt-Level Reflection
  printSection('Part 1: Prompt-Level Reflection (Schema Validation)');
  {
    console.log('Demonstrates: enableReflection on prompt config');
    console.log('Behavior: Auto-retry when schema validation fails\n');

    const workflow = new PromptReflectionWorkflow('PromptReflection');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    const result = await workflow.run();

    console.log('\nExecution summary:');
    console.log(`  Attempts: ${workflow.attemptCount}`);
    console.log(`  Validation errors: ${workflow.validationErrors.length}`);
    if (workflow.validationErrors.length > 0) {
      console.log(`  Errors encountered:`);
      for (const error of workflow.validationErrors) {
        console.log(`    - ${error}`);
      }
    }

    if (result) {
      console.log(`\nFinal result:`);
      console.log(`  Answer: ${result.answer.slice(0, 50)}...`);
      console.log(`  Confidence: ${result.confidence}`);
    }

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 2: Agent-Level Reflection
  printSection('Part 2: Agent-Level Reflection (Self-Correction)');
  {
    console.log('Demonstrates: agent.reflect() method with system prompt prefix');
    console.log('Behavior: Agent reviews reasoning before final answer\n');

    const workflow = new AgentReflectionWorkflow('AgentReflection');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    const result = await workflow.run();

    console.log('Reflection history:');
    for (const entry of workflow.reflectionHistory) {
      console.log(`  ${entry.attempt}. ${entry.action}: ${entry.result}`);
    }

    if (result) {
      console.log(`\nAnalysis result:`);
      console.log(`  Summary: ${result.summary}`);
      console.log(`  Key points: ${result.keyPoints.length}`);
      console.log(`  Recommendation: ${result.recommendation}`);
    }

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 3: Workflow-Level Reflection
  printSection('Part 3: Workflow-Level Reflection (Step Retry)');
  {
    console.log('Demonstrates: executeWithReflection() wrapper');
    console.log('Behavior: Retry failed steps with reflection analysis\n');

    const workflow = new WorkflowReflectionWorkflow('WorkflowReflection');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    await workflow.run();

    console.log('\nStep attempt summary:');
    for (const [step, attempts] of Object.entries(workflow.stepAttempts)) {
      console.log(`  ${step}: ${attempts} attempt(s)`);
    }

    console.log(`\nFailure reasons:`);
    for (const reason of workflow.failureReasons) {
      console.log(`  - ${reason}`);
    }

    console.log(`\nSuccessful steps: ${workflow.successfulSteps.join(', ')}`);

    // Show reflection history
    const history = workflow['reflectionManager'].getReflectionHistory();
    console.log(`\nReflection history entries: ${history.length}`);
    for (const entry of history) {
      console.log(`  [${entry.level}] ${entry.reason} -> ${entry.resolution}`);
    }

    console.log('\nTree:');
    console.log(debugger_.toTreeString());
  }

  // Part 4: Multi-Level Combined
  printSection('Part 4: Multi-Level Reflection Overview');
  {
    console.log('All three levels working together:\n');

    const workflow = new MultiLevelReflectionWorkflow('MultiLevelReflection');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    await workflow.run();

    console.log('Reflection events by level:');
    const byLevel = workflow.reflectionEvents.reduce(
      (acc, event) => {
        acc[event.level] = (acc[event.level] ?? 0) + 1;
        return acc;
      },
      {} as Record<string, number>
    );

    for (const [level, count] of Object.entries(byLevel)) {
      console.log(`  ${level}: ${count} event(s)`);
    }

    console.log('\nReflection configuration defaults:');
    console.log(`  Enabled: ${DEFAULT_REFLECTION_CONFIG.enabled}`);
    console.log(`  Max attempts: ${DEFAULT_REFLECTION_CONFIG.maxAttempts}`);
    console.log(`  Retry delay: ${DEFAULT_REFLECTION_CONFIG.retryDelayMs}ms`);

    console.log('\nTree:');
    console.log(debugger_.toTreeString());

    const stats = debugger_.getStats();
    console.log('\nFinal statistics:', stats);
  }

  console.log('\n=== Example 9 Complete ===');
}

// Allow direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  runReflectionExample().catch(console.error);
}


================================================================================
EXAMPLE: EXAMPLE 10: INTROSPECTION
File: examples/examples/10-introspection.ts
================================================================================

/**
 * Example 10: Introspection Tools Demo
 *
 * Demonstrates:
 * - Agent with INTROSPECTION_TOOLS
 * - inspect_current_node - "Where am I?"
 * - read_ancestor_chain - "What's above me?"
 * - list_siblings_children - "What's around me?"
 * - inspect_prior_outputs - "What happened before?"
 * - inspect_cache_status - "Is this cached?"
 * - request_spawn_workflow - "Can I create children?"
 */

import { z } from 'zod';
import {
  Workflow,
  Step,
  Task,
  ObservedState,
  WorkflowTreeDebugger,
  INTROSPECTION_TOOLS,
  INTROSPECTION_HANDLERS,
  handleInspectCurrentNode,
  handleReadAncestorChain,
  handleListSiblingsChildren,
  handleInspectPriorOutputs,
  handleInspectCacheStatus,
  handleRequestSpawnWorkflow,
  runInContext,
  createChildContext,
  agentExecutionStorage,
  defaultCache,
} from 'groundswell';
import type {
  CurrentNodeInfo,
  AncestorChainResult,
  SiblingsChildrenResult,
  PriorOutputInfo,
  CacheStatusResult,
  SpawnWorkflowRequest,
  WorkflowNode,
  AgentExecutionContext,
} from 'groundswell';
import { printHeader, printSection, sleep, prettyJson } from '../utils/helpers.js';

// ============================================================================
// Helper to simulate execution context
// ============================================================================

/**
 * Create a mock workflow node for demonstration
 */
function createMockNode(
  name: string,
  parent?: WorkflowNode,
  status: 'idle' | 'running' | 'completed' = 'running'
): WorkflowNode {
  return {
    id: `node-${name}-${Date.now()}`,
    name,
    status,
    parent,
    children: [],
    events: [],
  };
}

/**
 * Execute a function within a mock execution context
 */
async function executeInMockContext<T>(
  node: WorkflowNode,
  fn: () => Promise<T>
): Promise<T> {
  const context: AgentExecutionContext = {
    workflowId: node.id,
    workflowName: node.name,
    workflowNode: node,
    emitEvent: (event) => {
      node.events.push(event);
    },
  };

  return runInContext(context, fn);
}

// ============================================================================
// Workflow Definitions
// ============================================================================

/**
 * Root workflow for introspection demonstration
 */
class IntrospectionDemoWorkflow extends Workflow {
  @ObservedState()
  introspectionResults: Record<string, unknown> = {};

  constructor(name: string, parent?: Workflow) {
    super(name, parent);
  }

  @Step({ trackTiming: true, snapshotState: true })
  async setupStep(): Promise<string> {
    this.logger.info('Setting up introspection demo');
    await sleep(50);
    return 'Setup complete';
  }

  @Step({ trackTiming: true, snapshotState: true })
  async processStep(): Promise<string> {
    this.logger.info('Processing data');
    await sleep(50);
    return 'Processing complete';
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting introspection demo workflow');

    await this.setupStep();
    await this.processStep();

    this.setStatus('completed');
  }
}

/**
 * Child workflow for nested hierarchy demonstration
 */
class ChildIntrospectionWorkflow extends Workflow {
  @ObservedState()
  depth: number;

  constructor(name: string, depth: number, parent?: Workflow) {
    super(name, parent);
    this.depth = depth;
  }

  @Step({ trackTiming: true })
  async childWork(): Promise<string> {
    this.logger.info(`Child at depth ${this.depth} working`);
    await sleep(30);
    return `Child ${this.depth} result`;
  }

  async run(): Promise<string> {
    this.setStatus('running');
    const result = await this.childWork();
    this.setStatus('completed');
    return result;
  }
}

// ============================================================================
// Introspection Tool Demonstrations
// ============================================================================

/**
 * Demonstrate inspect_current_node tool
 */
async function demonstrateCurrentNode(): Promise<void> {
  console.log('Tool: inspect_current_node');
  console.log('Purpose: "Where am I?" - Get info about current workflow node\n');

  // Create mock hierarchy
  const root = createMockNode('RootWorkflow');
  const child = createMockNode('ChildWorkflow', root);
  root.children.push(child);

  await executeInMockContext(child, async () => {
    const result = await handleInspectCurrentNode();

    console.log('Result:');
    console.log(`  ID: ${result.id}`);
    console.log(`  Name: ${result.name}`);
    console.log(`  Status: ${result.status}`);
    console.log(`  Parent ID: ${result.parentId ?? '(none)'}`);
    console.log(`  Parent Name: ${result.parentName ?? '(none)'}`);
    console.log(`  Child Count: ${result.childCount}`);
    console.log(`  Depth: ${result.depth}`);
  });
}

/**
 * Demonstrate read_ancestor_chain tool
 */
async function demonstrateAncestorChain(): Promise<void> {
  console.log('Tool: read_ancestor_chain');
  console.log('Purpose: "What\'s above me?" - Get all ancestor nodes\n');

  // Create 3-level hierarchy
  const root = createMockNode('RootWorkflow', undefined, 'running');
  const level1 = createMockNode('Level1Workflow', root, 'running');
  const level2 = createMockNode('Level2Workflow', level1, 'running');
  root.children.push(level1);
  level1.children.push(level2);

  await executeInMockContext(level2, async () => {
    const result = await handleReadAncestorChain({ maxDepth: 10 });

    console.log(`Total depth: ${result.totalDepth}`);
    console.log('Ancestors (from current to root):');
    for (const ancestor of result.ancestors) {
      console.log(`  Depth ${ancestor.depth}: ${ancestor.name} [${ancestor.status}]`);
    }
  });
}

/**
 * Demonstrate list_siblings_children tool
 */
async function demonstrateSiblingsChildren(): Promise<void> {
  console.log('Tool: list_siblings_children');
  console.log('Purpose: "What\'s around me?" - List siblings or children\n');

  // Create hierarchy with siblings
  const root = createMockNode('RootWorkflow', undefined, 'running');
  const sibling1 = createMockNode('Sibling1', root, 'completed');
  const sibling2 = createMockNode('Sibling2', root, 'running');
  const sibling3 = createMockNode('Sibling3', root, 'idle');
  root.children.push(sibling1, sibling2, sibling3);

  // Add children to sibling2
  const child1 = createMockNode('Child1', sibling2, 'completed');
  const child2 = createMockNode('Child2', sibling2, 'running');
  sibling2.children.push(child1, child2);

  await executeInMockContext(sibling2, async () => {
    // Get siblings
    const siblings = await handleListSiblingsChildren({ type: 'siblings' });
    console.log('Siblings:');
    for (const node of siblings.nodes) {
      console.log(`  - ${node.name} [${node.status}]`);
    }

    // Get children
    const children = await handleListSiblingsChildren({ type: 'children' });
    console.log('\nChildren:');
    for (const node of children.nodes) {
      console.log(`  - ${node.name} [${node.status}]`);
    }
  });
}

/**
 * Demonstrate inspect_prior_outputs tool
 */
async function demonstratePriorOutputs(): Promise<void> {
  console.log('Tool: inspect_prior_outputs');
  console.log('Purpose: "What happened before?" - Get outputs from prior steps\n');

  // Create hierarchy with completed siblings
  const root = createMockNode('RootWorkflow', undefined, 'running');
  const step1 = createMockNode('Step1', root, 'completed');
  const step2 = createMockNode('Step2', root, 'completed');
  const step3 = createMockNode('CurrentStep', root, 'running');

  // Add events to completed steps
  step1.events.push({ type: 'stepEnd', payload: { result: 'Step 1 output' } });
  step2.events.push({ type: 'stepEnd', payload: { result: 'Step 2 output' } });

  root.children.push(step1, step2, step3);

  await executeInMockContext(step3, async () => {
    const result = await handleInspectPriorOutputs({ count: 3 });

    console.log(`Found ${result.length} prior outputs:`);
    for (const output of result) {
      console.log(`  Node: ${output.nodeName}`);
      console.log(`  Status: ${output.status}`);
      console.log(`  Events: ${output.events.length}`);
    }
  });
}

/**
 * Demonstrate inspect_cache_status tool
 */
async function demonstrateCacheStatus(): Promise<void> {
  console.log('Tool: inspect_cache_status');
  console.log('Purpose: "Is this cached?" - Check if a prompt response is cached\n');

  // Set up some cache entries
  const testKey1 = 'test-prompt-hash-12345';
  const testKey2 = 'test-prompt-hash-67890';

  await defaultCache.set(testKey1, { result: 'Cached response' });

  // Check existing key
  const result1 = await handleInspectCacheStatus({ promptHash: testKey1 });
  console.log(`Key "${testKey1}":`);
  console.log(`  Exists: ${result1.exists}`);

  // Check non-existing key
  const result2 = await handleInspectCacheStatus({ promptHash: testKey2 });
  console.log(`\nKey "${testKey2}":`);
  console.log(`  Exists: ${result2.exists}`);

  // Show cache metrics
  const metrics = defaultCache.metrics();
  console.log('\nCache metrics:');
  console.log(`  Entries: ${metrics.entries}`);
  console.log(`  Hits: ${metrics.hits}`);
  console.log(`  Misses: ${metrics.misses}`);
}

/**
 * Demonstrate request_spawn_workflow tool
 */
async function demonstrateSpawnWorkflow(): Promise<void> {
  console.log('Tool: request_spawn_workflow');
  console.log('Purpose: "Can I create children?" - Request to spawn new workflow\n');

  const root = createMockNode('OrchestratorWorkflow');

  await executeInMockContext(root, async () => {
    const request = await handleRequestSpawnWorkflow({
      name: 'DynamicChildWorkflow',
      description: 'Process additional data discovered during execution',
    });

    console.log('Spawn request created:');
    console.log(`  Name: ${request.name}`);
    console.log(`  Description: ${request.description}`);
    console.log(`  Request ID: ${request.requestId}`);
    console.log(`  Status: ${request.status}`);
    console.log('\nNote: The orchestrator handles actual spawning based on this request.');
  });
}

// ============================================================================
// Complete Integration Demo
// ============================================================================

/**
 * Workflow that uses introspection tools
 */
class IntrospectiveWorkflow extends Workflow {
  @ObservedState()
  introspectionLog: Array<{ tool: string; result: unknown }> = [];

  constructor(name: string, parent?: Workflow) {
    super(name, parent);
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'introspect-position' })
  async introspectPosition(): Promise<void> {
    this.logger.info('Using introspection to understand position');

    // Create context for this step
    const stepNode = createMockNode('introspect-position', undefined, 'running');

    await executeInMockContext(stepNode, async () => {
      const nodeInfo = await handleInspectCurrentNode();
      this.introspectionLog.push({ tool: 'inspect_current_node', result: nodeInfo });
      this.logger.info(`Position: ${nodeInfo.name} at depth ${nodeInfo.depth}`);
    });
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'analyze-hierarchy' })
  async analyzeHierarchy(): Promise<void> {
    this.logger.info('Analyzing workflow hierarchy');

    // Create a mock hierarchy for demo
    const root = createMockNode('Root');
    const parent = createMockNode('Parent', root);
    const current = createMockNode('Current', parent);
    root.children.push(parent);
    parent.children.push(current);

    await executeInMockContext(current, async () => {
      const ancestors = await handleReadAncestorChain({ maxDepth: 5 });
      this.introspectionLog.push({ tool: 'read_ancestor_chain', result: ancestors });
      this.logger.info(`Found ${ancestors.ancestors.length} ancestors`);
    });
  }

  @Step({ trackTiming: true, snapshotState: true, name: 'check-cache' })
  async checkCache(): Promise<void> {
    this.logger.info('Checking cache status');

    const testHash = 'demo-prompt-hash';
    const cacheStatus = await handleInspectCacheStatus({ promptHash: testHash });
    this.introspectionLog.push({ tool: 'inspect_cache_status', result: cacheStatus });
    this.logger.info(`Cache hit: ${cacheStatus.exists}`);
  }

  async run(): Promise<void> {
    this.setStatus('running');
    this.logger.info('Starting introspective workflow');

    await this.introspectPosition();
    await this.analyzeHierarchy();
    await this.checkCache();

    this.logger.info(`Total introspection calls: ${this.introspectionLog.length}`);
    this.setStatus('completed');
  }
}

// ============================================================================
// Main Example Runner
// ============================================================================

/**
 * Run the Introspection Tools example
 */
export async function runIntrospectionExample(): Promise<void> {
  printHeader('Example 10: Introspection Tools Demo');

  // Overview of available tools
  printSection('Available Introspection Tools');
  {
    console.log('The INTROSPECTION_TOOLS array contains 6 tools:\n');
    for (const tool of INTROSPECTION_TOOLS) {
      console.log(`  ${tool.name}`);
      console.log(`    ${tool.description}`);
      console.log(`    Required: ${tool.input_schema.required?.join(', ') || 'none'}\n`);
    }
  }

  // Part 1: inspect_current_node
  printSection('Part 1: inspect_current_node');
  {
    await demonstrateCurrentNode();
  }

  // Part 2: read_ancestor_chain
  printSection('Part 2: read_ancestor_chain');
  {
    await demonstrateAncestorChain();
  }

  // Part 3: list_siblings_children
  printSection('Part 3: list_siblings_children');
  {
    await demonstrateSiblingsChildren();
  }

  // Part 4: inspect_prior_outputs
  printSection('Part 4: inspect_prior_outputs');
  {
    await demonstratePriorOutputs();
  }

  // Part 5: inspect_cache_status
  printSection('Part 5: inspect_cache_status');
  {
    await demonstrateCacheStatus();
  }

  // Part 6: request_spawn_workflow
  printSection('Part 6: request_spawn_workflow');
  {
    await demonstrateSpawnWorkflow();
  }

  // Part 7: Complete Integration
  printSection('Part 7: Complete Workflow with Introspection');
  {
    console.log('Workflow using multiple introspection tools:\n');

    const workflow = new IntrospectiveWorkflow('IntrospectiveWorkflow');
    const debugger_ = new WorkflowTreeDebugger(workflow);

    await workflow.run();

    console.log('\nIntrospection log:');
    for (const entry of workflow.introspectionLog) {
      console.log(`  Tool: ${entry.tool}`);
      if (typeof entry.result === 'object' && entry.result !== null) {
        const summary =
          'exists' in entry.result
            ? `exists: ${entry.result.exists}`
            : 'name' in entry.result
              ? `name: ${(entry.result as { name: string }).name}`
              : 'ancestors' in entry.result
                ? `${(entry.result as { ancestors: unknown[] }).ancestors.length} ancestors`
                : JSON.stringify(entry.result).slice(0, 50);
        console.log(`  Result: ${summary}`);
      }
      console.log('');
    }

    console.log('Tree:');
    console.log(debugger_.toTreeString());
  }

  // Part 8: Agent Integration Pattern
  printSection('Part 8: Agent Integration Pattern');
  {
    console.log('Pattern for agents using introspection tools:\n');

    console.log(`// Agent configuration with introspection tools
const introspectionAgent = createAgent({
  name: 'IntrospectionAgent',
  tools: INTROSPECTION_TOOLS,
  system: \`You are an agent that can explore workflow hierarchies.
           Use the introspection tools to understand your position
           and what work has been done.\`
});

// Prompt for self-aware analysis
const explorePrompt = createPrompt({
  user: 'Describe your position in the workflow and summarize prior work.',
  responseFormat: z.object({
    position: z.string(),
    depth: z.number(),
    parentName: z.string().optional(),
    summary: z.string()
  })
});

// Agent uses tools autonomously to gather context
const analysis = await introspectionAgent.prompt(explorePrompt);
`);

    console.log('\nThe agent can:');
    console.log('  1. Call inspect_current_node to understand its position');
    console.log('  2. Call read_ancestor_chain to understand hierarchy');
    console.log('  3. Call list_siblings_children to see nearby nodes');
    console.log('  4. Call inspect_prior_outputs to review prior work');
    console.log('  5. Call inspect_cache_status to check for cached results');
    console.log('  6. Call request_spawn_workflow to request child workflows');
  }

  // Summary
  printSection('Summary');
  {
    console.log('Introspection tools enable agents to:');
    console.log('  - Understand their position in the workflow hierarchy');
    console.log('  - Access context from parent and sibling workflows');
    console.log('  - Review outputs from prior execution steps');
    console.log('  - Check cache status before expensive operations');
    console.log('  - Request dynamic workflow spawning\n');

    console.log('All tools are:');
    console.log('  - Read-only (except request_spawn_workflow)');
    console.log('  - Security-filtered (sensitive data removed)');
    console.log('  - Context-aware (use getExecutionContext())');
    console.log('  - Result-limited (prevent overwhelming output)');
  }

  console.log('\n=== Example 10 Complete ===');
}

// Allow direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  runIntrospectionExample().catch(console.error);
}

