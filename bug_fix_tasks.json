{
  "backlog": [
    {
      "type": "Phase",
      "id": "P1",
      "title": "Bug Fix: attachChild() Tree Integrity Violation",
      "status": "Planned",
      "description": "Fix critical bug in attachChild() method that allows creating inconsistent tree state by attaching a child workflow to multiple parents. Includes adding parent validation, circular reference detection, and implementing detachChild() method for proper reparenting support.",
      "milestones": [
        {
          "type": "Milestone",
          "id": "P1.M1",
          "title": "Core Validation Implementation",
          "status": "Complete",
          "description": "Implement the primary fix for attachChild() by adding parent state validation and circular reference detection to prevent inconsistent tree state.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M1.T1",
              "title": "Add Parent Validation to attachChild()",
              "status": "Complete",
              "description": "Modify the attachChild() method in src/core/workflow.ts to validate if child already has a parent before attaching. Throw clear error if child.parent is already set to a different workflow.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S1",
                  "title": "Write failing test for parent validation",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md - The bug is in src/core/workflow.ts:187-201. The current attachChild() only checks if child is already attached to THIS workflow, not if child has a different parent.\n2. INPUT: Use Workflow class from src/core/workflow.ts. Create two parent workflows and one child workflow.\n3. LOGIC: Implement test that creates child with parent1, then attempts to attach to parent2. Verify Error is thrown with message containing 'already has a parent'. Mock console.log to verify error message is helpful.\n4. OUTPUT: Export test function that can be imported by Vitest. Test must fail initially (red), then pass after implementation in S2."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S2",
                  "title": "Implement parent validation check",
                  "status": "Complete",
                  "story_points": 2,
                  "dependencies": [
                    "P1.M1.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 1 - Add validation after the existing duplicate check (line 189-191 in current code). Check both child.parent !== null AND child.parent !== this.\n2. INPUT: Access child.parent property from S1's test. The child workflow instance with pre-existing parent.\n3. LOGIC: In src/core/workflow.ts attachChild() method, after line 191, add: if (child.parent !== null && child.parent !== this) { throw new Error(...) }. Include current parent's name in error message. Suggest using detachChild() first.\n4. OUTPUT: Updated attachChild() method that throws Error when child has existing parent. Error message must include both workflow names and suggest solution."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T1.S3",
                  "title": "Verify test passes and no regression",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - Test suite has 241 tests. All must pass after changes.\n2. INPUT: Run Vitest on the entire test suite. The test from S1 should now pass (green).\n3. LOGIC: Execute 'npm test' or equivalent Vitest command. Verify all 241 existing tests still pass. Verify the new test from S1 passes. Check for any test failures in observer propagation or tree tests.\n4. OUTPUT: Test run results showing 242+ tests passing. Report any failing tests with error messages. If regressions found, document them for next iteration."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M1.T2",
              "title": "Add Circular Reference Detection",
              "status": "Complete",
              "description": "Implement isDescendantOf() helper method and add circular reference validation to attachChild() to prevent attaching an ancestor as a child, which would create cycles in the tree.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S1",
                  "title": "Write failing test for circular reference detection",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 2 - Circular references occur when attaching an ancestor as a child. Example: root -> child1 -> child2, then child2.attachChild(root).\n2. INPUT: Use Workflow class. Create 3-level hierarchy: root, child1 (child of root), child2 (child of child1).\n3. LOGIC: Write test that attempts child2.attachChild(root). Should throw Error with message containing 'circular' or 'cycle' or 'ancestor'. Also test that immediate cycle (child.attachChild(parent)) throws.\n4. OUTPUT: Export test functions for both scenarios. Tests must fail initially (red), then pass after S2 implementation."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S2",
                  "title": "Implement isDescendantOf() helper method",
                  "status": "Complete",
                  "story_points": 2,
                  "dependencies": [
                    "P1.M1.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 2 - isDescendantOf() traverses parent chain from this upward. Use visited Set for cycle detection during traversal itself.\n2. INPUT: Access this.parent chain from within Workflow instance. The ancestor parameter to check against.\n3. LOGIC: In src/core/workflow.ts, add private method isDescendantOf(ancestor: Workflow): boolean. Start with current = this, visited = new Set(). While current !== null: if visited.has(current) throw Error (cycle in traversal); if current === ancestor return true; visited.add(current); current = current.parent. Return false at end.\n4. OUTPUT: Private isDescendantOf() method that returns true if ancestor is found in parent chain, false otherwise. Throws if cycle detected during traversal."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S3",
                  "title": "Integrate circular reference check into attachChild()",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md - Add circular reference check AFTER parent validation but BEFORE updating tree state. Order of validations matters.\n2. INPUT: Use the isDescendantOf() method from S2. The child parameter from attachChild().\n3. LOGIC: In src/core/workflow.ts attachChild() method, after parent validation from T1.S2, add: if (this.isDescendantOf(child)) { throw new Error('Cannot attach child...it is an ancestor...This would create a circular reference') }. Include both workflow names in error.\n4. OUTPUT: Updated attachChild() with circular reference check. Tests from S1 should now pass."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M1.T2.S4",
                  "title": "Verify no regressions in full test suite",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M1.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - 241 existing tests. All must pass. No observer propagation breaks.\n2. INPUT: Run full Vitest suite. The circular reference tests from S1.\n3. LOGIC: Execute 'npm test'. Verify all 241+ tests pass. Specifically check getRoot() tests (should still work). Check observer propagation tests. Check tree debugger tests.\n4. OUTPUT: Test run results showing all passing. Report any failures. If regressions, document and fix."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M2",
          "title": "Reparenting Support",
          "status": "Complete",
          "description": "Implement detachChild() method to enable proper reparenting workflow, allowing users to move a child from one parent to another without creating inconsistent state.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M2.T1",
              "title": "Implement detachChild() Method",
              "status": "Complete",
              "description": "Add detachChild() method to Workflow class that properly removes a child from both the workflow tree and node tree, clears the child's parent reference, and emits a childDetached event.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S1",
                  "title": "Add childDetached event type to events.ts",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md - Event types are in src/types/events.ts as discriminated union. Need to add childDetached type.\n2. INPUT: Access existing WorkflowEvent type definition from src/types/events.ts. Follow pattern of childAttached event.\n3. LOGIC: Add new case to WorkflowEvent discriminated union: { type: 'childDetached'; parentId: string; childId: string }. Use childId (string) instead of child (WorkflowNode) because child is no longer in tree. Follow existing pattern exactly.\n4. OUTPUT: Updated WorkflowEvent type in src/types/events.ts with childDetached case. TypeScript must compile without errors."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S2",
                  "title": "Write failing tests for detachChild()",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 4 - detachChild() should remove from both trees, clear parent, emit event.\n2. INPUT: Use Workflow class from src/core/workflow.ts. Create parent with child.\n3. LOGIC: Write tests: (1) detachChild removes child from parent.children, (2) clears child.parent to null, (3) removes from parent.node.children, (4) emits childDetached event, (5) throws if child not attached. Mock observer to verify event received.\n4. OUTPUT: Export 5 test functions. All must fail initially (method doesn't exist yet), then pass after S3."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S3",
                  "title": "Implement detachChild() method",
                  "status": "Complete",
                  "story_points": 2,
                  "dependencies": [
                    "P1.M2.T1.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 4 - detachChild() must remove from this.children, this.node.children, clear child.parent, emit event. Order: validate, remove from arrays, clear reference, emit.\n2. INPUT: The child Workflow parameter. Access this.children array and this.node.children array.\n3. LOGIC: In src/core/workflow.ts, add public method detachChild(child: Workflow): void. First find index: const index = this.children.indexOf(child). If index === -1 throw Error. Then: this.children.splice(index, 1). Find in node.children and splice. Set child.parent = null. Emit childDetached event with this.id and child.id.\n4. OUTPUT: Working detachChild() method. All tests from S2 pass. Maintains bidirectional tree consistency."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T1.S4",
                  "title": "Update emitEvent() to handle childDetached events",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T1.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 6 - emitEvent() calls onTreeChanged() for tree update events like childAttached. Need to add childDetached.\n2. INPUT: Access emitEvent() method in src/core/workflow.ts. The event parameter with type: 'childDetached'.\n3. LOGIC: In emitEvent() method, find the conditional that checks for tree update events (currently checks event.type === 'treeUpdated' || event.type === 'childAttached'). Add ' || event.type === \"childDetached\"' to condition. This ensures onTreeChanged() is called for detach operations.\n4. OUTPUT: Updated emitEvent() that triggers onTreeChanged() callback for childDetached events. Observers receive tree change notifications."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M2.T2",
              "title": "Test Reparenting Workflow",
              "status": "Complete",
              "description": "Write comprehensive tests for the reparenting workflow (detach from old parent, attach to new parent) to ensure observer propagation updates correctly.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M2.T2.S1",
                  "title": "Write reparenting integration test",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T1.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 7 - Observer propagation should update after reparenting. Events from child should only reach new parent's observers.\n2. INPUT: Use Workflow class with observer support. Create parent1 and parent2 with observers. Create child with parent1.\n3. LOGIC: Write test that: (1) attaches child to parent1, (2) emits event, verifies parent1 observer receives it, (3) detaches from parent1, (4) attaches to parent2, (5) emits event, verifies parent2 observer receives it, (6) verifies parent1 observer does NOT receive it. Use arrays to collect events.\n4. OUTPUT: Integration test that verifies complete reparenting workflow with observer propagation."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M2.T2.S2",
                  "title": "Verify tree consistency after reparenting",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M2.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - Must maintain 1:1 tree mirror between workflow tree and node tree after all operations.\n2. INPUT: Use WorkflowTreeDebugger to inspect tree structure. The parent and child workflows from S1.\n3. LOGIC: Write test that reparents child, then uses WorkflowTreeDebugger to verify: child.parent points to new parent, new parent.children includes child, old parent.children does NOT include child, node tree mirrors workflow tree exactly.\n4. OUTPUT: Test that validates bidirectional tree consistency after reparenting. Uses debugger API to verify tree structure."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M3",
          "title": "Comprehensive Testing & Validation",
          "status": "Complete",
          "description": "Add adversarial tests, edge case coverage, and verify PRD compliance. Ensure all 241+ existing tests still pass and new functionality is thoroughly tested.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M3.T1",
              "title": "Add Adversarial and Edge Case Tests",
              "status": "Complete",
              "description": "Write comprehensive adversarial tests to ensure the tree integrity fixes are robust against intentional misuse, unexpected inputs, and edge cases.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S1",
                  "title": "Write deep hierarchy stress test",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 8 - Test deep hierarchies (1000+ levels) to ensure no stack overflow in getRoot() or isDescendantOf().\n2. INPUT: Use Workflow class. Loop to create chain of 1000+ nested workflows.\n3. LOGIC: Write test that creates root, then attaches child1, child2, etc. 1000 times deep. Then call getRoot() on deepest child and verify it returns root without stack overflow. Also test isDescendantOf() doesn't overflow.\n4. OUTPUT: Stress test that verifies no stack overflow or performance issues with deep trees."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S2",
                  "title": "Write manual parent mutation test",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 8 - Even if someone manually mutates parent with 'as any', attachChild() should still validate.\n2. INPUT: Use Workflow class. Create parent1, parent2, child with parent1.\n3. LOGIC: Write test that manually mutates: (child as any).parent = parent2. Then try parent1.attachChild(child). Should throw because child.parent is now parent2, not parent1. Validates defensive programming works even with manual mutation.\n4. OUTPUT: Test that proves attachChild() validation works even if parent is manually mutated."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S3",
                  "title": "Write complex circular reference tests",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md Pattern 8 - Test cycles at various depths: immediate child, grandchild, great-grandchild.\n2. INPUT: Use Workflow class. Create 4-level hierarchy: root, child1, child2, child3.\n3. LOGIC: Write tests for: (1) child.attachChild(parent) - immediate cycle, (2) child2.attachChild(root) - 2-level cycle, (3) child3.attachChild(root) - 3-level cycle. All should throw with 'circular' or 'ancestor' in message.\n4. OUTPUT: Three test cases covering different cycle depths. All should pass with isDescendantOf() detection."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T1.S4",
                  "title": "Write bidirectional consistency tests",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - PRD requires 1:1 mirror between workflow tree and node tree. Must verify this is maintained.\n2. INPUT: Use Workflow class with parent/child. Access both this.children and this.node.children.\n3. LOGIC: Write tests that verify after attachChild(): child.parent === parent AND child.node.parent === parent.node. After detachChild(): child.parent === null AND parent.node.children does NOT contain child.node. Test with multiple children, deep trees.\n4. OUTPUT: Tests that enforce bidirectional consistency invariant. Both trees must match at all times."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M3.T2",
              "title": "Verify PRD Compliance",
              "status": "Complete",
              "description": "Verify that all fixes comply with PRD Section 12.2 requirements and other relevant sections. Create a compliance checklist and verify each requirement.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S1",
                  "title": "Verify PRD Section 12.2 compliance",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T1.S4"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - PRD Section 12.2 requires: child has exactly one parent, child.parent matches parent, child appears in only one parent's children array.\n2. INPUT: Reference PRD document (attached to original project initiation). The fixed attachChild() and detachChild() implementations.\n3. LOGIC: Create compliance test that explicitly checks PRD requirements: (1) create child with parent, verify child.parent === parent, (2) try to attach to second parent, should throw, (3) verify child only appears in one children array, (4) verify node tree mirrors workflow tree.\n4. OUTPUT: PRD compliance test with clear assertions for each requirement. Document any deviations."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S2",
                  "title": "Verify observer propagation (PRD Section 7)",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md - Bug broke observer propagation. Fix must ensure events reach correct observers via getRoot().\n2. INPUT: Use Workflow class with addObserver. Create 3-level tree: root, child, grandchild. Add observer to root.\n3. LOGIC: Write test that emits events from grandchild, verifies root observer receives them. After reparenting grandchild to different root, verify events go to new root's observer, not old root's. Validates getRoot() follows parent chain correctly.\n4. OUTPUT: Observer propagation test that verifies PRD Section 7 requirements are met. Events bubble to root observers correctly."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M3.T2.S3",
                  "title": "Run full test suite and verify all pass",
                  "status": "Complete",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M3.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - Original suite had 241 tests. After adding all new tests, should have 260+ tests. ALL must pass.\n2. INPUT: Run Vitest on entire src/__tests__ directory. All test files.\n3. LOGIC: Execute 'npm test' or 'vitest run'. Capture total test count and pass/fail status. Review any failing tests. If failures exist, determine if they're regressions from our changes or pre-existing issues. Document results.\n4. OUTPUT: Final test report with total count (expected 260+), pass rate (must be 100%), and list of any failures with analysis."
                }
              ]
            }
          ]
        },
        {
          "type": "Milestone",
          "id": "P1.M4",
          "title": "Documentation & Final Validation",
          "status": "Planned",
          "description": "Update documentation, create usage examples for the new reparenting workflow, and perform final validation to ensure the fix is production-ready.",
          "tasks": [
            {
              "type": "Task",
              "id": "P1.M4.T1",
              "title": "Update Documentation and Examples",
              "status": "Planned",
              "description": "Update code documentation (JSDoc comments) for attachChild(), detachChild(), and isDescendantOf(). Create usage examples showing correct reparenting workflow.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M4.T1.S1",
                  "title": "Add JSDoc comments to modified methods",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md - attachChild() now throws new errors. detachChild() is new. isDescendantOf() is new. All need JSDoc.\n2. INPUT: The modified methods in src/core/workflow.ts. Follow existing JSDoc patterns in the file.\n3. LOGIC: Add JSDoc comments above attachChild() documenting the two new error cases (has parent, circular ref). Add JSDoc for detachChild() with @throws documentation. Add JSDoc for isDescendantOf() explaining it's a private helper. Use @param, @throws, @returns tags.\n4. OUTPUT: Well-documented methods with clear JSDoc comments. IDE shows documentation on hover. TypeScript generates proper types."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T1.S2",
                  "title": "Create reparenting usage example",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M4.T1.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md Migration Path - Users need to know how to properly reparent workflows with the new API.\n2. INPUT: Use Workflow class API. Document the detach-then-attach pattern.\n3. LOGIC: Create example file or documentation comment showing: (1) WRONG way (attaching directly throws), (2) RIGHT way (detach first, then attach). Show complete example with error handling. Explain why this is necessary.\n4. OUTPUT: Usage example code that can be included in README, docs, or examples directory. Shows correct reparenting pattern."
                }
              ]
            },
            {
              "type": "Task",
              "id": "P1.M4.T2",
              "title": "Final Validation and Release Preparation",
              "status": "Planned",
              "description": "Perform final validation checks including TypeScript compilation, linting, performance testing, and create a summary of changes for the release.",
              "subtasks": [
                {
                  "type": "Subtask",
                  "id": "P1.M4.T2.S1",
                  "title": "Verify TypeScript compilation and type checking",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/system_context.md - Project uses TypeScript. All types must be correct. New event type was added.\n2. INPUT: Run TypeScript compiler (tsc) on entire project. The modified src/types/events.ts and src/core/workflow.ts files.\n3. LOGIC: Execute 'npm run build' or 'tsc --noEmit'. Verify no type errors. Check that childDetached event type is properly typed. Verify WorkflowEvent discriminated union works correctly. Verify observer onEvent() accepts new event type.\n4. OUTPUT: TypeScript compilation succeeds with no errors. All types are correct."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T2.S2",
                  "title": "Check for performance regressions",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M4.T2.S1"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/implementation_patterns.md - Added isDescendantOf() which traverses parent chain. Could impact performance in hot paths.\n2. INPUT: Create performance test or benchmark. Large tree with 1000+ workflows. Measure attachChild() time.\n3. LOGIC: Write performance test that times attachChild() before and after fix. Create 100-workflow tree, measure total time. Verify overhead is minimal (<10% slower). If regression is significant, optimize isDescendantOf() or add caching.\n4. OUTPUT: Performance test results showing acceptable overhead. Document any performance characteristics."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T2.S3",
                  "title": "Create change summary and release notes",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M4.T2.S2"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md - Critical bug fix with new detachChild() API. Breaking changes: none (fixes buggy behavior).\n2. INPUT: All changes made: attachChild() validation, isDescendantOf(), detachChild(), childDetached event, tests.\n3. LOGIC: Create CHANGELOG entry or release notes summarizing: (1) Bug fixed: attachChild() no longer allows inconsistent state, (2) New feature: detachChild() method, (3) New event: childDetached, (4) Migration guide for users affected by bug fix, (5) Test count increase.\n4. OUTPUT: Release notes document suitable for GitHub release, CHANGELOG.md, or version notes. Clear description of changes and impact."
                },
                {
                  "type": "Subtask",
                  "id": "P1.M4.T2.S4",
                  "title": "Final validation checklist",
                  "status": "Planned",
                  "story_points": 1,
                  "dependencies": [
                    "P1.M4.T2.S3"
                  ],
                  "context_scope": "CONTRACT DEFINITION:\n1. RESEARCH NOTE: From plan/bugfix/architecture/bug_analysis.md Validation Checklist - 10 items to verify before considering fix complete.\n2. INPUT: The complete implementation and test suite. The validation checklist from bug analysis.\n3. LOGIC: Go through checklist: [x] Implementation matches PRD, [x] All tests pass, [x] Observer works, [x] Tree debugger consistent, [x] getRoot() correct, [x] Clear errors, [x] Circular detection works, [x] Reparenting works, [x] Code follows patterns, [x] Types correct, [x] No performance regression.\n4. OUTPUT: Completed validation checklist. Any items marked as failures must be addressed before release."
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}